@page "/"
@using Task = System.Threading.Tasks.Task
@using TaskFlow.Domain
@using DomainTaskStatus = TaskFlow.Domain.TaskStatus
@implements IDisposable
@inject IProjectOrchestrator ProjectOrchestrator
@inject ITaskOrchestrator TaskOrchestrator
@inject IMyTaskFlowSectionOrchestrator MyTaskFlowSectionOrchestrator
@inject ISnackbar Snackbar
@inject IJSRuntime JsRuntime

<PageTitle>TaskFlow</PageTitle>

<div class="tf-home" tabindex="0" @onkeydown="HandleShellKeyDown">
    <section class="tf-main">
        <header class="tf-toolbar">
            <div>
                <MudText Typo="Typo.h5">@CurrentTitle</MudText>
                <MudText Typo="Typo.caption">@CurrentSubtitle</MudText>
            </div>
            <MudStack Row="true" Spacing="1">
                <MudTooltip Text="Keyboard shortcuts">
                    <MudButton Variant="Variant.Outlined" OnClick="ToggleShortcutsHelp">Shortcuts</MudButton>
                </MudTooltip>
                @if (selectedProject is not null)
                {
                    <MudTooltip Text="Toggle list/board view">
                        <MudButton Variant="Variant.Outlined" OnClick="ToggleProjectViewAsync">@ViewToggleLabel</MudButton>
                    </MudTooltip>
                    <MudTooltip Text="Edit project">
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" OnClick="OpenEditProjectDialogAsync" />
                    </MudTooltip>
                    <MudTooltip Text="Delete project">
                        <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="OpenDeleteProjectDialog">Delete Project</MudButton>
                    </MudTooltip>
                }
            </MudStack>
        </header>

        <MudPaper Class="tf-filters" Elevation="0">
            <MudTextField @bind-Value="searchQuery"
                          @ref="searchInputRef"
                          Placeholder="Search tasks"
                          Immediate="true"
                          DebounceInterval="150"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search" />
            <MudSelect T="TaskPriority?" @bind-Value="priorityFilter" Label="Priority" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem T="TaskPriority?" Value="null">All</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.High">High</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Medium">Medium</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Low">Low</MudSelectItem>
            </MudSelect>
            <MudSelect T="DomainTaskStatus?" @bind-Value="statusFilter" Label="Status" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem T="DomainTaskStatus?" Value="null">All</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Todo">Todo</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Doing">Doing</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Done">Done</MudSelectItem>
            </MudSelect>
            <MudSelect T="SortMode" @bind-Value="sortMode" Label="Sort" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@SortMode.CreatedDesc">Newest</MudSelectItem>
                <MudSelectItem Value="@SortMode.CreatedAsc">Oldest</MudSelectItem>
                <MudSelectItem Value="@SortMode.Priority">Priority</MudSelectItem>
                <MudSelectItem Value="@SortMode.Focused">Focused</MudSelectItem>
            </MudSelect>
            <MudSwitch @bind-Value="showCompleted" Label="Show completed" Color="Color.Primary" />
            <MudTooltip Text="Delete all completed tasks">
                <MudButton Variant="Variant.Outlined" Color="Color.Warning" OnClick="ClearCompletedAsync">Clear Completed</MudButton>
            </MudTooltip>
        </MudPaper>

        <MudPaper Class="tf-create-row" Elevation="0">
            <MudTextField @bind-Value="newTaskTitle"
                          @ref="newTaskInputRef"
                          Label="Create task"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Immediate="true"
                          TextUpdateSuppression="false"
                          OnKeyUp="HandleCreateTaskKeyDown" />
            <MudSelect T="TaskPriority" @bind-Value="newTaskPriority" Label="Priority" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@TaskPriority.High">High</MudSelectItem>
                <MudSelectItem Value="@TaskPriority.Medium">Medium</MudSelectItem>
                <MudSelectItem Value="@TaskPriority.Low">Low</MudSelectItem>
            </MudSelect>
            <MudTooltip Text="Add task">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateTaskAsync">Add</MudButton>
            </MudTooltip>
        </MudPaper>

        @if (selectedProject?.ViewType == ProjectViewType.Board)
        {
            <TaskBoardView BoardStatuses="boardStatuses"
                           GetBoardTasks="GetBoardTasks"
                           OnDropTaskToStatus="HandleBoardDropAsync"
                           OnCreateTaskInStatus="CreateTaskInStatusAsync"
                           OnEditTaskRequested="OpenBoardTaskDialog"
                           />
        }
        else
        {
            <HomeListView Tasks="FilteredTasks"
                          OnEditTaskRequested="OpenBoardTaskDialog" />
        }

    </section>
</div>

@if (showShortcuts)
{
    <div class="tf-shortcuts-backdrop" @onclick="ToggleShortcutsHelp">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Keyboard shortcuts</MudText>
            <p>Ctrl/Cmd + Enter: complete selected task</p>
            <p>Delete: delete selected task</p>
            <p>Ctrl/Cmd + N: focus new task</p>
            <p>Ctrl/Cmd + F: focus search</p>
            <p>Ctrl/Cmd + P: toggle focus pin on selected task</p>
            <p>Ctrl/Cmd + Z: undo last action</p>
            <p>Ctrl/Cmd + /: toggle this help</p>
        </MudPaper>
    </div>
}

@if (showDeleteProjectDialog)
{
    <div class="tf-shortcuts-backdrop" @onclick="CloseDeleteProjectDialog">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Delete this project?</MudText>
            <p>This will remove the project and its tasks.</p>
            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Outlined" OnClick="CloseDeleteProjectDialog">Cancel</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="DeleteProjectAsync">Delete</MudButton>
            </MudStack>
        </MudPaper>
    </div>
}

@code {
    private const int MaxUndoActions = 20;

    private enum SortMode
    {
        CreatedDesc,
        CreatedAsc,
        Priority,
        Focused,
    }

    private readonly DomainTaskStatus[] boardStatuses = [DomainTaskStatus.Todo, DomainTaskStatus.Doing, DomainTaskStatus.Done];
    private readonly Dictionary<Guid, List<TaskFlow.Domain.Task>> subTasksByParent = [];
    private readonly Dictionary<Guid, string> newSubTaskTitles = [];
    private readonly Stack<UndoAction> undoActions = new();
    private readonly (string Hex, string Name)[] projectColorOptions =
    [
        ("#2D9CFF", "Ocean Blue"),
        ("#30C76A", "Mint Green"),
        ("#F2B01E", "Amber"),
        ("#EF4B6C", "Coral Red"),
        ("#9B5DE5", "Violet"),
        ("#14B8A6", "Teal"),
        ("#F97316", "Orange"),
        ("#64748B", "Slate"),
    ];

    private List<TaskFlow.Domain.Task> activeTasks = [];
    private Guid? selectedTaskId;
    private string editProjectName = string.Empty;
    private string editProjectColor = "#2D9CFF";
    private string editProjectIcon = "folder";
    private string newTaskTitle = string.Empty;
    private TaskPriority newTaskPriority = TaskPriority.Medium;
    private string searchQuery = string.Empty;
    private TaskPriority? priorityFilter;
    private DomainTaskStatus? statusFilter;
    private bool showCompleted;
    private bool showShortcuts;
    private bool showDeleteProjectDialog;
    private bool showEditProjectDialog;
    private bool showMoveTaskDialog;
    private bool showBoardTaskDialog;
    private bool isApplyingUndo;
    private SortMode sortMode = SortMode.CreatedDesc;
    private MudTextField<string> newTaskInputRef;
    private MudTextField<string> searchInputRef;
    private Guid? moveTaskId;
    private Guid? moveTargetProjectId;
    private Guid? boardTaskId;
    private Guid? pendingSubTaskFocusParentId;
    private Guid? loadedProjectId;
    private Guid? loadedSectionId;
    private DotNetObjectReference<Home> editProjectDialogCloserRef;

    private sealed record UndoAction(string Description, Func<Task> UndoAsync);

    private sealed record TaskSnapshot(
        string Title,
        string Note,
        TaskPriority Priority,
        DomainTaskStatus Status,
        bool IsFocused,
        bool IsMarkedForToday,
        Guid? ProjectId,
        List<TaskSnapshot> Children);

    private Project selectedProject => this.AppState.SelectedProjectId.HasValue
        ? this.AppState.Projects.FirstOrDefault(p => p.Id == this.AppState.SelectedProjectId.Value)
        : null;

    [CascadingParameter]
    public AppState AppState { get; set; } = null!;

    private string CurrentTitle => this.selectedProject?.Name
        ?? this.AppState.MyTaskFlowSections.FirstOrDefault(s => s.Id == this.AppState.SelectedSectionId)?.Name
        ?? "TaskFlow";

    private string CurrentSubtitle => this.selectedProject is null
        ? "Cross-project execution view"
        : $"{FilteredTasks.Count} task(s)";

    private string ViewToggleLabel => this.selectedProject?.ViewType == ProjectViewType.Board ? "List View" : "Board View";

    private TaskFlow.Domain.Task boardTask => this.boardTaskId.HasValue
        ? this.activeTasks.FirstOrDefault(task => task.Id == this.boardTaskId.Value)
        : null;

    private List<TaskFlow.Domain.Task> FilteredTasks
    {
        get
        {
            IEnumerable<TaskFlow.Domain.Task> query = this.activeTasks;

            if (!string.IsNullOrWhiteSpace(this.searchQuery))
            {
                var normalized = this.searchQuery.Trim();
                query = query.Where(task =>
                    task.Title.Contains(normalized, StringComparison.OrdinalIgnoreCase)
                    || (task.Note?.Contains(normalized, StringComparison.OrdinalIgnoreCase) ?? false));
            }

            if (this.priorityFilter.HasValue)
            {
                query = query.Where(task => task.Priority == this.priorityFilter.Value);
            }

            if (this.statusFilter.HasValue)
            {
                query = query.Where(task => task.Status == this.statusFilter.Value);
            }

            if (!this.showCompleted)
            {
                query = query.Where(task => !task.IsCompleted);
            }

            query = this.sortMode switch
            {
                SortMode.CreatedAsc => query.OrderBy(task => task.CreatedAt),
                SortMode.Priority => query.OrderByDescending(task => task.Priority).ThenByDescending(task => task.CreatedAt),
                SortMode.Focused => query.Where(task => task.IsFocused).OrderByDescending(task => task.CreatedAt),
                _ => query.OrderByDescending(task => task.CreatedAt),
            };

            return query.Where(task => !task.ParentTaskId.HasValue).ToList();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        this.AppState.Changed += OnAppStateChanged;
        await ReloadAllAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (this.loadedProjectId != this.AppState.SelectedProjectId
            || this.loadedSectionId != this.AppState.SelectedSectionId)
        {
            await ApplySelectionAsync();
            return;
        }

        if (!this.pendingSubTaskFocusParentId.HasValue)
        {
            return;
        }

        var parentTaskId = this.pendingSubTaskFocusParentId.Value;
        this.pendingSubTaskFocusParentId = null;
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusById", GetSubTaskInputId(parentTaskId));
    }

    private async Task ReloadAllAsync()
    {
        var projects = (await this.ProjectOrchestrator.GetAllAsync()).OrderBy(project => project.CreatedAt).ToList();
        var myTaskFlowSections = await this.MyTaskFlowSectionOrchestrator.GetAllAsync();
        var taskCounts = await BuildProjectTaskCountsAsync(projects);

        this.AppState.SetNavigationData(projects, myTaskFlowSections, taskCounts);
        await ApplySelectionAsync();
    }

    private void OnAppStateChanged()
    {
        _ = InvokeAsync(ApplySelectionAsync);
    }

    private async Task ApplySelectionAsync()
    {
        if (this.loadedProjectId == this.AppState.SelectedProjectId
            && this.loadedSectionId == this.AppState.SelectedSectionId)
        {
            StateHasChanged();
            return;
        }

        if (this.AppState.SelectedProjectId.HasValue)
        {
            await LoadProjectTasksAsync(this.AppState.SelectedProjectId.Value);
            this.loadedProjectId = this.AppState.SelectedProjectId;
            this.loadedSectionId = null;
            var currentProject = this.AppState.Projects.FirstOrDefault(project => project.Id == this.AppState.SelectedProjectId.Value);
            if (currentProject is not null)
            {
                SetProjectEditor(currentProject);
            }
        }
        else if (this.AppState.SelectedSectionId.HasValue)
        {
            await LoadSectionTasksAsync(this.AppState.SelectedSectionId.Value);
            this.loadedProjectId = null;
            this.loadedSectionId = this.AppState.SelectedSectionId;
        }
        else
        {
            this.activeTasks.Clear();
            this.subTasksByParent.Clear();
            this.loadedProjectId = null;
            this.loadedSectionId = null;
        }

        StateHasChanged();
    }

    private async Task LoadProjectTasksAsync(Guid projectId)
    {
        this.activeTasks = await this.TaskOrchestrator.GetByProjectIdAsync(projectId);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks)
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task LoadSectionTasksAsync(Guid sectionId)
    {
        var section = this.AppState.MyTaskFlowSections.FirstOrDefault(item => item.Id == sectionId);
        if (section is null)
        {
            this.activeTasks.Clear();
            this.subTasksByParent.Clear();
            return;
        }

        this.activeTasks = await this.MyTaskFlowSectionOrchestrator.GetSectionTasksAsync(section);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks.Where(x => !x.ParentTaskId.HasValue))
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task OpenEditProjectDialogAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        SetProjectEditor(this.selectedProject);
        this.editProjectDialogCloserRef?.Dispose();
        this.editProjectDialogCloserRef = DotNetObjectReference.Create(this);
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.registerEditProjectCloser", this.editProjectDialogCloserRef);
        this.showEditProjectDialog = true;
    }

    private void CloseEditProjectDialog()
    {
        this.showEditProjectDialog = false;
        _ = this.JsRuntime.InvokeVoidAsync("taskflowUi.registerEditProjectCloser", (object)null);
    }

    private async Task OnProjectNameEditedAsync(string value)
    {
        if (this.selectedProject is null || string.Equals(this.selectedProject.Name, value, StringComparison.Ordinal))
        {
            return;
        }

        this.editProjectName = value;
        await this.ProjectOrchestrator.UpdateNameAsync(this.selectedProject.Id, value);
        await ReloadAllAsync();
    }

    private async Task OnProjectColorEditedAsync(string value)
    {
        if (this.selectedProject is null || string.Equals(this.selectedProject.Color, value, StringComparison.Ordinal))
        {
            return;
        }

        this.editProjectColor = value;
        await this.ProjectOrchestrator.UpdateVisualsAsync(this.selectedProject.Id, value, this.editProjectIcon);
        await ReloadAllAsync();
    }

    private async Task OnProjectIconEditedAsync(string value)
    {
        if (this.selectedProject is null || string.Equals(this.selectedProject.Icon, value, StringComparison.Ordinal))
        {
            return;
        }

        this.editProjectIcon = value;
        await this.ProjectOrchestrator.UpdateVisualsAsync(this.selectedProject.Id, this.editProjectColor, value);
        await ReloadAllAsync();
    }

    private void OpenDeleteProjectDialog()
    {
        this.showDeleteProjectDialog = true;
    }

    private void CloseDeleteProjectDialog()
    {
        this.showDeleteProjectDialog = false;
    }

    private void OpenMoveTaskDialog(Guid taskId)
    {
        this.moveTaskId = taskId;
        this.moveTargetProjectId = this.activeTasks.FirstOrDefault(task => task.Id == taskId)?.ProjectId;
        this.showMoveTaskDialog = true;
    }

    private void CloseMoveTaskDialog()
    {
        this.showMoveTaskDialog = false;
        this.moveTaskId = null;
        this.moveTargetProjectId = null;
    }

    private void OpenBoardTaskDialog(Guid taskId)
    {
        this.selectedTaskId = taskId;
        this.boardTaskId = taskId;
        this.showBoardTaskDialog = true;
    }

    private void CloseBoardTaskDialog()
    {
        this.showBoardTaskDialog = false;
        this.boardTaskId = null;
    }

    private async Task ConfirmMoveTaskAsync()
    {
        if (!this.moveTaskId.HasValue)
        {
            return;
        }

        var task = this.activeTasks.FirstOrDefault(item => item.Id == this.moveTaskId.Value);
        if (task is null)
        {
            CloseMoveTaskDialog();
            return;
        }

        await MoveTaskAsync(task, this.moveTargetProjectId);
        CloseMoveTaskDialog();
    }

    private async Task HandleBoardDropAsync(TaskFlow.Domain.Task task, DomainTaskStatus status)
    {
        if (task.Status == status)
        {
            return;
        }

        await UpdateStatusAsync(task, status);
    }

    private async Task DeleteProjectAsync()
    {
        if (this.selectedProject is null || this.selectedProject.IsDefault)
        {
            this.Snackbar.Add("Default project cannot be deleted.", Severity.Warning);
            return;
        }

        await this.ProjectOrchestrator.DeleteAsync(this.selectedProject.Id);
        this.showDeleteProjectDialog = false;
        await ReloadAllAsync();
        this.Snackbar.Add("Project deleted.", Severity.Info);
    }

    private async Task CreateTaskAsync()
    {
        if (string.IsNullOrWhiteSpace(this.newTaskTitle))
        {
            return;
        }

        if (this.AppState.SelectedProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(this.AppState.SelectedProjectId.Value, this.newTaskTitle, this.newTaskPriority, string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(this.newTaskTitle, this.newTaskPriority, string.Empty);
        }

        this.newTaskTitle = string.Empty;
        await InvokeAsync(StateHasChanged);
        if (this.newTaskInputRef is not null)
        {
            await this.newTaskInputRef.FocusAsync();
        }

        await ReloadCurrentTasksAsync();
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateTaskInStatusAsync(DomainTaskStatus status, string title)
    {
        if (string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        TaskFlow.Domain.Task created;
        if (this.AppState.SelectedProjectId.HasValue)
        {
            created = await this.TaskOrchestrator.CreateAsync(this.AppState.SelectedProjectId.Value, title, TaskPriority.Medium, string.Empty);
        }
        else
        {
            created = await this.TaskOrchestrator.CreateUnassignedAsync(title, TaskPriority.Medium, string.Empty);
        }

        if (status != DomainTaskStatus.Todo)
        {
            await this.TaskOrchestrator.SetStatusAsync(created.Id, status);
        }

        await ReloadCurrentTasksAsync();
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateSubTaskAsync(Guid parentTaskId)
    {
        if (!this.newSubTaskTitles.TryGetValue(parentTaskId, out var title) || string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId, title, TaskPriority.Medium, string.Empty);

        this.newSubTaskTitles[parentTaskId] = string.Empty;
        this.pendingSubTaskFocusParentId = parentTaskId;
        await ReloadCurrentTasksAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleCreateSubTaskKeyUp(Guid parentTaskId, KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateSubTaskAsync(parentTaskId);
        }
    }

    private async Task ToggleCompleteAsync(TaskFlow.Domain.Task task)
    {
        var target = task.IsCompleted ? DomainTaskStatus.Todo : DomainTaskStatus.Done;
        var previousStatus = task.Status;
        PushUndoAction("toggle completion", async () =>
        {
            await this.TaskOrchestrator.SetStatusAsync(task.Id, previousStatus);
        });

        await this.TaskOrchestrator.SetStatusAsync(task.Id, target);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        var statusMessage = target == DomainTaskStatus.Done ? "Task completed." : "Task restored.";
        this.Snackbar.Add($"{statusMessage} Press Ctrl/Cmd+Z to undo.", Severity.Success);
    }

    private async Task UpdateTitleAsync(TaskFlow.Domain.Task task, string value)
    {
        if (string.Equals(task.Title, value, StringComparison.Ordinal))
        {
            return;
        }

        await this.TaskOrchestrator.UpdateTitleAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateNoteAsync(TaskFlow.Domain.Task task, string value)
    {
        await this.TaskOrchestrator.UpdateNoteAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdatePriorityAsync(TaskFlow.Domain.Task task, TaskPriority priority)
    {
        await this.TaskOrchestrator.SetPriorityAsync(task.Id, priority);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateStatusAsync(TaskFlow.Domain.Task task, DomainTaskStatus status)
    {
        await this.TaskOrchestrator.SetStatusAsync(task.Id, status);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleFocusAsync(TaskFlow.Domain.Task task)
    {
        var wasFocused = task.IsFocused;
        PushUndoAction("toggle focus", async () =>
        {
            var current = this.activeTasks.FirstOrDefault(x => x.Id == task.Id);
            if (current is null || current.IsFocused != wasFocused)
            {
                await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
            }
        });

        await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleImportantAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleImportantAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task DeleteTaskAsync(TaskFlow.Domain.Task task)
    {
        var snapshot = await CaptureTaskSnapshotAsync(task);
        PushUndoAction("delete task", async () =>
        {
            await RestoreTaskSnapshotAsync(snapshot);
        });

        await this.TaskOrchestrator.DeleteAsync(task.Id);
        if (this.boardTaskId == task.Id)
        {
            CloseBoardTaskDialog();
        }
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task deleted. Press Ctrl/Cmd+Z to undo.", Severity.Info);
    }

    private async Task DuplicateTaskAsync(TaskFlow.Domain.Task task)
    {
        var title = $"{task.Title} (Copy)";
        if (task.ProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(task.ProjectId.Value, title, task.Priority, task.Note ?? string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(title, task.Priority, task.Note ?? string.Empty);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task duplicated.", Severity.Info);
    }

    private async Task ToggleTodayMarkAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleTodayMarkAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task MoveTaskAsync(TaskFlow.Domain.Task task, Guid? projectId)
    {
        var previousProjectId = task.ProjectId;
        PushUndoAction("move task", async () =>
        {
            if (previousProjectId.HasValue)
            {
                await this.TaskOrchestrator.MoveToProjectAsync(task.Id, previousProjectId.Value);
            }
            else
            {
                await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
            }
        });

        if (projectId.HasValue)
        {
            await this.TaskOrchestrator.MoveToProjectAsync(task.Id, projectId.Value);
        }
        else
        {
            await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        await RecalculateProjectTaskCountsAsync();
        StateHasChanged();
        this.Snackbar.Add("Task moved.", Severity.Info);
    }

    private async Task ToggleProjectViewAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var next = this.selectedProject.ViewType == ProjectViewType.Board
            ? ProjectViewType.List
            : ProjectViewType.Board;
        await this.ProjectOrchestrator.UpdateViewTypeAsync(this.selectedProject.Id, next);
        await ReloadAllAsync();
    }

    private async Task ClearCompletedAsync()
    {
        var completed = this.activeTasks.Where(task => task.IsCompleted).ToList();
        var completedIds = completed.Select(task => task.Id).ToHashSet();
        var rootCompleted = completed.Where(task => !task.ParentTaskId.HasValue || !completedIds.Contains(task.ParentTaskId.Value)).ToList();
        var snapshots = new List<TaskSnapshot>();
        foreach (var task in rootCompleted)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(task));
        }

        PushUndoAction("clear completed tasks", async () =>
        {
            foreach (var snapshot in snapshots)
            {
                await RestoreTaskSnapshotAsync(snapshot);
            }
        });

        foreach (var task in completed)
        {
            await this.TaskOrchestrator.DeleteAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add($"Cleared {completed.Count} completed task(s). Press Ctrl/Cmd+Z to undo.", Severity.Warning);
    }

    private async Task ReloadCurrentTasksAsync()
    {
        if (this.AppState.SelectedProjectId.HasValue)
        {
            await LoadProjectTasksAsync(this.AppState.SelectedProjectId.Value);
            this.loadedProjectId = this.AppState.SelectedProjectId;
            this.loadedSectionId = null;
            return;
        }

        if (this.AppState.SelectedSectionId.HasValue)
        {
            await LoadSectionTasksAsync(this.AppState.SelectedSectionId.Value);
            this.loadedProjectId = null;
            this.loadedSectionId = this.AppState.SelectedSectionId;
        }
    }

    private List<TaskFlow.Domain.Task> GetBoardTasks(DomainTaskStatus status)
    {
        return this.FilteredTasks.Where(task => task.Status == status).ToList();
    }

    private async Task RecalculateProjectTaskCountsAsync()
    {
        var counts = await BuildProjectTaskCountsAsync(this.AppState.Projects);
        this.AppState.SetProjectTaskCounts(counts);
    }

    private async Task<Dictionary<Guid, int>> BuildProjectTaskCountsAsync(IReadOnlyList<Project> projects)
    {
        var counts = new Dictionary<Guid, int>();
        foreach (var project in projects)
        {
            var projectTasks = await this.TaskOrchestrator.GetByProjectIdAsync(project.Id);
            var count = projectTasks.Count(task => !task.IsCompleted);
            foreach (var task in projectTasks)
            {
                var subtasks = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
                count += subtasks.Count(subTask => !subTask.IsCompleted);
            }

            counts[project.Id] = count;
        }

        return counts;
    }

    private void SetProjectEditor(Project project)
    {
        this.editProjectName = project.Name;
        this.editProjectColor = project.Color;
        this.editProjectIcon = project.Icon;
    }

    private string GetTaskContainerClass(TaskFlow.Domain.Task task, bool isSubTask)
    {
        var baseClass = isSubTask ? "tf-subtask" : "tf-task";
        if (!task.CompletedAt.HasValue)
        {
            return baseClass;
        }

        return task.CompletedAt.Value >= DateTime.UtcNow.AddMinutes(-15)
            ? $"{baseClass} tf-task-recent"
            : baseClass;
    }

    private void PushUndoAction(string description, Func<Task> undoAsync)
    {
        if (this.isApplyingUndo)
        {
            return;
        }

        if (this.undoActions.Count >= MaxUndoActions)
        {
            this.undoActions.Clear();
        }

        this.undoActions.Push(new UndoAction(description, undoAsync));
    }

    private async Task UndoLastActionAsync()
    {
        if (!this.undoActions.TryPop(out var action))
        {
            this.Snackbar.Add("Nothing to undo.", Severity.Normal);
            return;
        }

        try
        {
            this.isApplyingUndo = true;
            await action.UndoAsync();
            await ReloadCurrentTasksAsync();
            await RecalculateProjectTaskCountsAsync();
            this.Snackbar.Add($"Undid: {action.Description}", Severity.Success);
        }
        finally
        {
            this.isApplyingUndo = false;
        }
    }

    private async Task<TaskSnapshot> CaptureTaskSnapshotAsync(TaskFlow.Domain.Task task)
    {
        var children = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        var snapshots = new List<TaskSnapshot>();
        foreach (var child in children)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(child));
        }

        return new TaskSnapshot(
            task.Title,
            task.Note ?? string.Empty,
            task.Priority,
            task.Status,
            task.IsFocused,
            task.IsMarkedForToday,
            task.ProjectId,
            snapshots);
    }

    private async Task RestoreTaskSnapshotAsync(TaskSnapshot snapshot, Guid? parentTaskId = null)
    {
        TaskFlow.Domain.Task recreated;
        if (parentTaskId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else if (snapshot.ProjectId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateAsync(snapshot.ProjectId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else
        {
            recreated = await this.TaskOrchestrator.CreateUnassignedAsync(snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }

        if (snapshot.Status != DomainTaskStatus.Todo)
        {
            await this.TaskOrchestrator.SetStatusAsync(recreated.Id, snapshot.Status);
        }

        if (snapshot.IsFocused)
        {
            await this.TaskOrchestrator.ToggleFocusAsync(recreated.Id);
        }

        if (snapshot.IsMarkedForToday)
        {
            await this.TaskOrchestrator.ToggleTodayMarkAsync(recreated.Id);
        }

        foreach (var child in snapshot.Children)
        {
            await RestoreTaskSnapshotAsync(child, recreated.Id);
        }
    }

    private string GetNewSubTaskTitle(Guid parentTaskId)
    {
        return this.newSubTaskTitles.TryGetValue(parentTaskId, out var value) ? value : string.Empty;
    }

    private static string GetSubTaskInputId(Guid parentTaskId)
    {
        return $"subtask-input-{parentTaskId:N}";
    }

    private void SetNewSubTaskTitle(Guid parentTaskId, string value)
    {
        this.newSubTaskTitles[parentTaskId] = value;
    }

    private async Task HandleCreateTaskKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateTaskAsync();
        }
    }

    private Task HandleEditProjectDialogKeyDown(KeyboardEventArgs args)
    {
        if (string.Equals(args.Key, "Enter", StringComparison.OrdinalIgnoreCase)
            || string.Equals(args.Key, "NumpadEnter", StringComparison.OrdinalIgnoreCase))
        {
            CloseEditProjectDialog();
        }

        return Task.CompletedTask;
    }

    private Task HandleEditProjectSubmit()
    {
        CloseEditProjectDialog();
        return Task.CompletedTask;
    }

    private async Task HandleShellKeyDown(KeyboardEventArgs args)
    {
        if (this.showEditProjectDialog && (args.Key == "Enter" || args.Key == "NumpadEnter"))
        {
            CloseEditProjectDialog();
            return;
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("Enter", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleCompleteAsync(task);
            }
        }

        if (args.Key == "Delete" && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await DeleteTaskAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("n", StringComparison.OrdinalIgnoreCase))
        {
            if (this.newTaskInputRef is not null)
            {
                await this.newTaskInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("f", StringComparison.OrdinalIgnoreCase))
        {
            if (this.searchInputRef is not null)
            {
                await this.searchInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("p", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleFocusAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("z", StringComparison.OrdinalIgnoreCase))
        {
            await UndoLastActionAsync();
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key == "/")
        {
            ToggleShortcutsHelp();
        }
    }

    private void ToggleShortcutsHelp()
    {
        this.showShortcuts = !this.showShortcuts;
    }

    [JSInvokable]
    public Task CloseEditProjectFromJs()
    {
        return InvokeAsync(() =>
        {
            if (this.showEditProjectDialog)
            {
                CloseEditProjectDialog();
                StateHasChanged();
            }
        });
    }

    public void Dispose()
    {
        this.AppState.Changed -= OnAppStateChanged;
        this.editProjectDialogCloserRef?.Dispose();
    }
}

@if (showEditProjectDialog)
{
    <div class="tf-shortcuts-backdrop" @onclick="CloseEditProjectDialog">
        <div id="edit-project-dialog">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <form @onsubmit="HandleEditProjectSubmit" @onkeydown="HandleEditProjectDialogKeyDown" @onkeyup="HandleEditProjectDialogKeyDown">
            <MudText Typo="Typo.h6">Edit Project</MudText>
            <MudTextField T="string" Value="editProjectName" ValueChanged="OnProjectNameEditedAsync" Label="Project name" Variant="Variant.Outlined" Margin="Margin.Dense" OnKeyUp="HandleEditProjectDialogKeyDown" />
            <MudSelect T="string" Value="editProjectColor" ValueChanged="OnProjectColorEditedAsync" Label="Color" Variant="Variant.Outlined" Dense="true">
                @foreach (var option in projectColorOptions)
                {
                    <MudSelectItem Value="@option.Hex">
                        <span class="tf-color-option">
                            <span class="tf-color-swatch" style="@($"background:{option.Hex}")"></span>
                            <span>@option.Name</span>
                        </span>
                    </MudSelectItem>
                }
            </MudSelect>
            <MudSelect T="string" Value="editProjectIcon" ValueChanged="OnProjectIconEditedAsync" Label="Icon" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@("folder")">Folder</MudSelectItem>
                <MudSelectItem Value="@("inbox")">Inbox</MudSelectItem>
                <MudSelectItem Value="@("work")">Work</MudSelectItem>
                <MudSelectItem Value="@("code")">Code</MudSelectItem>
                <MudSelectItem Value="@("flag")">Flag</MudSelectItem>
            </MudSelect>
            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Outlined" ButtonType="ButtonType.Submit" Class="tf-edit-done-btn">Done</MudButton>
            </MudStack>
            </form>
        </MudPaper>
        </div>
    </div>
}

@if (showBoardTaskDialog && boardTask is not null)
{
    <TaskEditDialog Task="boardTask"
                    SubTasks="(subTasksByParent.TryGetValue(boardTask.Id, out var subTasks) ? subTasks : new List<TaskFlow.Domain.Task>())"
                    BoardStatuses="boardStatuses"
                    OnToggleComplete="ToggleCompleteAsync"
                    OnToggleFocus="ToggleFocusAsync"
                    OnToggleImportant="ToggleImportantAsync"
                    OnUpdateTitle="UpdateTitleAsync"
                    OnUpdateNote="UpdateNoteAsync"
                    OnUpdatePriority="UpdatePriorityAsync"
                    OnUpdateStatus="UpdateStatusAsync"
                    OnToggleToday="ToggleTodayMarkAsync"
                    OnDuplicate="DuplicateTaskAsync"
                    OnDelete="DeleteTaskAsync"
                    OnRequestMove="OpenMoveTaskDialog"
                    NewSubTaskTitle="GetNewSubTaskTitle(boardTask.Id)"
                    OnNewSubTaskTitleChanged="value => SetNewSubTaskTitle(boardTask.Id, value)"
                    OnCreateSubTask="() => CreateSubTaskAsync(boardTask.Id)"
                    OnClose="CloseBoardTaskDialog" />
}

@if (showMoveTaskDialog)
{
    <div class="tf-shortcuts-backdrop" @onclick="CloseMoveTaskDialog">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Move Task</MudText>
            <MudSelect T="Guid?" Value="moveTargetProjectId" ValueChanged="value => moveTargetProjectId = value" Label="Select project" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@((Guid?)null)">Unassigned</MudSelectItem>
                @foreach (var project in AppState.Projects)
                {
                    <MudSelectItem Value="@((Guid?)project.Id)">@project.Name</MudSelectItem>
                }
            </MudSelect>
            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Outlined" OnClick="CloseMoveTaskDialog">Cancel</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ConfirmMoveTaskAsync">Move</MudButton>
            </MudStack>
        </MudPaper>
    </div>
}
