@page "/"
@using Task = System.Threading.Tasks.Task
@using TaskFlow.Domain
@using DomainTaskStatus = TaskFlow.Domain.TaskStatus
@implements IDisposable
@inject IProjectOrchestrator ProjectOrchestrator
@inject ITaskOrchestrator TaskOrchestrator
@inject IMyTaskFlowSectionOrchestrator MyTaskFlowSectionOrchestrator
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JsRuntime
@inject IAppExceptionHandler UiExceptionHandler

<PageTitle>TaskFlow</PageTitle>

<div class="tf-home" tabindex="0" @onkeydown="HandleShellKeyDown">
    <section class="tf-main">
        <header class="tf-toolbar">
            <div>
                <MudText Typo="Typo.h5">@CurrentTitle</MudText>
                <MudText Typo="Typo.caption">@CurrentSubtitle</MudText>
            </div>
            <MudStack Row="true" Spacing="1">
                <MudTooltip Text="Keyboard shortcuts">
                    <MudButton Variant="Variant.Outlined" OnClick="ToggleShortcutsHelp">Shortcuts</MudButton>
                </MudTooltip>
                @if (selectedProject is not null)
                {
                    <MudTooltip Text="Toggle list/board view">
                        <MudButton Variant="Variant.Outlined" OnClick="ToggleProjectViewAsync">@ViewToggleLabel</MudButton>
                    </MudTooltip>
                    <MudTooltip Text="Edit project">
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" aria-label="Edit project" title="Edit project" OnClick="OpenEditProjectDialogAsync" />
                    </MudTooltip>
                    <MudTooltip Text="Delete project">
                        <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="OpenDeleteProjectDialogAsync">Delete Project</MudButton>
                    </MudTooltip>
                }
            </MudStack>
        </header>

        <MudPaper Class="tf-filters" Elevation="0">
            <MudTextField @bind-Value="searchQuery"
                          @ref="searchInputRef"
                          Placeholder="Search tasks"
                          Immediate="true"
                          DebounceInterval="150"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search" />
            <MudSelect T="TaskPriority?" @bind-Value="priorityFilter" Label="Priority" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem T="TaskPriority?" Value="null">All</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.High">High</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Medium">Medium</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Low">Low</MudSelectItem>
            </MudSelect>
            <MudSelect T="DomainTaskStatus?" @bind-Value="statusFilter" Label="Status" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem T="DomainTaskStatus?" Value="null">All</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Todo">Todo</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Doing">Doing</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Done">Done</MudSelectItem>
            </MudSelect>
            <MudSelect T="SortMode" @bind-Value="sortMode" Label="Sort" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@SortMode.CreatedDesc">Newest</MudSelectItem>
                <MudSelectItem Value="@SortMode.CreatedAsc">Oldest</MudSelectItem>
                <MudSelectItem Value="@SortMode.Priority">Priority</MudSelectItem>
                <MudSelectItem Value="@SortMode.Focused">Focused</MudSelectItem>
            </MudSelect>
            <MudSwitch @bind-Value="showCompleted" Label="Show completed" Color="Color.Primary" />
            <MudTooltip Text="Delete all completed tasks">
                <MudButton Variant="Variant.Outlined" Color="Color.Warning" OnClick="ClearCompletedAsync">Clear Completed</MudButton>
            </MudTooltip>
        </MudPaper>

        <MudPaper Class="tf-create-row" Elevation="0">
            <MudTextField @bind-Value="newTaskTitle"
                          @ref="newTaskInputRef"
                          Label="Create task"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Immediate="true"
                          TextUpdateSuppression="false"
                          OnKeyUp="HandleCreateTaskKeyDown" />
            <MudSelect T="TaskPriority" @bind-Value="newTaskPriority" Label="Priority" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@TaskPriority.High">High</MudSelectItem>
                <MudSelectItem Value="@TaskPriority.Medium">Medium</MudSelectItem>
                <MudSelectItem Value="@TaskPriority.Low">Low</MudSelectItem>
            </MudSelect>
            <MudTooltip Text="Add task">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateTaskAsync">Add</MudButton>
            </MudTooltip>
        </MudPaper>

        @if (isLoading)
        {
            <MudProgressLinear Class="mb-3" Color="Color.Primary" Indeterminate="true" />
        }
        else if (!string.IsNullOrWhiteSpace(loadError))
        {
            <MudAlert Severity="Severity.Error" Dense="true" Class="mb-3">
                @loadError
                <MudButton Variant="Variant.Text" Class="ml-2" OnClick="ReloadAllAsync">Retry</MudButton>
            </MudAlert>
        }
        else if (selectedProject?.ViewType == ProjectViewType.Board)
        {
            <TaskBoardView BoardStatuses="boardStatuses"
                           GetBoardTasks="GetBoardTasks"
                           OnDropTaskToStatus="HandleBoardDropAsync"
                           OnCreateTaskInStatus="CreateTaskInStatusAsync"
                           OnUpdateTaskTitleRequested="HandleBoardTaskTitleUpdateAsync"
                           OnEditTaskRequested="OpenBoardTaskDialog" />
        }
        else
        {
            <HomeListView Tasks="FilteredTasks"
                          OnUpdateTaskTitleRequested="HandleListTaskTitleUpdateAsync"
                          OnEditTaskRequested="OpenBoardTaskDialog" />
        }

    </section>
</div>

@if (showShortcuts)
{
    <div id="shortcuts-backdrop" class="tf-shortcuts-backdrop" tabindex="0" @onclick="ToggleShortcutsHelp" @onkeydown="HandleShortcutsKeyDown">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Keyboard shortcuts</MudText>
            <p>Ctrl/Cmd + Enter: complete selected task</p>
            <p>Delete: delete selected task</p>
            <p>Ctrl/Cmd + N: focus new task</p>
            <p>Ctrl/Cmd + F: focus search</p>
            <p>Ctrl/Cmd + P: toggle focus pin on selected task</p>
            <p>Ctrl/Cmd + Z: undo last action</p>
            <p>Ctrl/Cmd + /: toggle this help</p>
        </MudPaper>
    </div>
}

@code {
    private const int MaxUndoActions = 20;

    private enum SortMode
    {
        CreatedDesc,
        CreatedAsc,
        Priority,
        Focused,
    }

    private readonly DomainTaskStatus[] boardStatuses = [DomainTaskStatus.Todo, DomainTaskStatus.Doing, DomainTaskStatus.Done];
    private readonly Dictionary<Guid, List<TaskFlow.Domain.Task>> subTasksByParent = [];
    private readonly Dictionary<Guid, string> newSubTaskTitles = [];
    private readonly Stack<UndoAction> undoActions = new();
    private List<TaskFlow.Domain.Task> activeTasks = [];
    private Guid? selectedTaskId;
    private string newTaskTitle = string.Empty;
    private TaskPriority newTaskPriority = TaskPriority.Medium;
    private string searchQuery = string.Empty;
    private TaskPriority? priorityFilter;
    private DomainTaskStatus? statusFilter;
    private bool showCompleted;
    private bool showShortcuts;
    private bool showBoardTaskDialog;
    private bool isApplyingUndo;
    private bool isLoading;
    private bool pendingShortcutsFocus;
    private SortMode sortMode = SortMode.CreatedDesc;
    private string loadError;
    private MudTextField<string> newTaskInputRef;
    private MudTextField<string> searchInputRef;
    private DotNetObjectReference<Home> escapeHandlerReference;
    private Guid? boardTaskId;
    private Guid? pendingSubTaskFocusParentId;
    private Guid? loadedProjectId;
    private Guid? loadedSectionId;

    private sealed record UndoAction(string Description, Func<Task> UndoAsync);

    private sealed record TaskSnapshot(
        string Title,
        string Note,
        TaskPriority Priority,
        DomainTaskStatus Status,
        bool IsFocused,
        bool IsMarkedForToday,
        Guid? ProjectId,
        List<TaskSnapshot> Children);

    private Project selectedProject => this.AppState.SelectedProjectId.HasValue
        ? this.AppState.Projects.FirstOrDefault(p => p.Id == this.AppState.SelectedProjectId.Value)
        : null;

    [CascadingParameter]
    public AppState AppState { get; set; } = null!;

    private string CurrentTitle => this.selectedProject?.Name
        ?? this.AppState.MyTaskFlowSections.FirstOrDefault(s => s.Id == this.AppState.SelectedSectionId)?.Name
        ?? "TaskFlow";

    private string CurrentSubtitle => this.selectedProject is null
        ? "Cross-project execution view"
        : $"{FilteredTasks.Count} task(s)";

    private string ViewToggleLabel => this.selectedProject?.ViewType == ProjectViewType.Board ? "List View" : "Board View";

    private TaskFlow.Domain.Task boardTask => this.boardTaskId.HasValue
        ? this.activeTasks.FirstOrDefault(task => task.Id == this.boardTaskId.Value)
        : null;

    private List<TaskFlow.Domain.Task> FilteredTasks
    {
        get
        {
            IEnumerable<TaskFlow.Domain.Task> query = this.activeTasks;

            if (!string.IsNullOrWhiteSpace(this.searchQuery))
            {
                var normalized = this.searchQuery.Trim();
                query = query.Where(task =>
                    task.Title.Contains(normalized, StringComparison.OrdinalIgnoreCase)
                    || (task.Note?.Contains(normalized, StringComparison.OrdinalIgnoreCase) ?? false));
            }

            if (this.priorityFilter.HasValue)
            {
                query = query.Where(task => task.Priority == this.priorityFilter.Value);
            }

            if (this.statusFilter.HasValue)
            {
                query = query.Where(task => task.Status == this.statusFilter.Value);
            }

            if (!this.showCompleted && this.selectedProject?.ViewType != ProjectViewType.Board)
            {
                query = query.Where(task => !task.IsCompleted);
            }

            query = this.sortMode switch
            {
                SortMode.CreatedAsc => query.OrderBy(task => task.CreatedAt),
                SortMode.Priority => query.OrderByDescending(task => task.Priority).ThenByDescending(task => task.CreatedAt),
                SortMode.Focused => query.Where(task => task.IsFocused).OrderByDescending(task => task.CreatedAt),
                _ => query.OrderByDescending(task => task.CreatedAt),
            };

            return query.Where(task => !task.ParentTaskId.HasValue).ToList();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        this.AppState.Changed += OnAppStateChanged;
        await ReloadAllAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && this.escapeHandlerReference is null)
        {
            this.escapeHandlerReference = DotNetObjectReference.Create(this);
            await this.JsRuntime.InvokeVoidAsync("taskflowUi.registerEscapeHandler", this.escapeHandlerReference);
        }

        if (this.loadedProjectId != this.AppState.SelectedProjectId
            || this.loadedSectionId != this.AppState.SelectedSectionId)
        {
            await ApplySelectionAsync();
            return;
        }

        if (this.pendingShortcutsFocus && this.showShortcuts)
        {
            this.pendingShortcutsFocus = false;
            await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusById", "shortcuts-backdrop");
        }

        if (!this.pendingSubTaskFocusParentId.HasValue)
        {
            return;
        }

        var parentTaskId = this.pendingSubTaskFocusParentId.Value;
        this.pendingSubTaskFocusParentId = null;
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusById", GetSubTaskInputId(parentTaskId));
    }

    private async Task ReloadAllAsync()
    {
        this.isLoading = true;
        this.loadError = null;
        try
        {
            var projects = (await this.ProjectOrchestrator.GetAllAsync()).OrderBy(project => project.CreatedAt).ToList();
            var myTaskFlowSections = await this.MyTaskFlowSectionOrchestrator.GetAllAsync();
            var taskCounts = await BuildProjectTaskCountsAsync(projects);

            this.AppState.SetNavigationData(projects, myTaskFlowSections, taskCounts);
            await ApplySelectionAsync();
        }
        catch (Exception ex)
        {
            this.UiExceptionHandler.Handle(ex, "Home - ReloadAll");
            this.loadError = "Could not load data. Please try again.";
        }
        finally
        {
            this.isLoading = false;
        }
    }

    private void OnAppStateChanged()
    {
        _ = InvokeAsync(ApplySelectionAsync);
    }

    private async Task ApplySelectionAsync()
    {
        this.loadError = null;
        if (this.loadedProjectId == this.AppState.SelectedProjectId
            && this.loadedSectionId == this.AppState.SelectedSectionId)
        {
            StateHasChanged();
            return;
        }

        try
        {
            if (this.AppState.SelectedProjectId.HasValue)
            {
                await LoadProjectTasksAsync(this.AppState.SelectedProjectId.Value);
                this.loadedProjectId = this.AppState.SelectedProjectId;
                this.loadedSectionId = null;
            }
            else if (this.AppState.SelectedSectionId.HasValue)
            {
                await LoadSectionTasksAsync(this.AppState.SelectedSectionId.Value);
                this.loadedProjectId = null;
                this.loadedSectionId = this.AppState.SelectedSectionId;
            }
            else
            {
                this.activeTasks.Clear();
                this.subTasksByParent.Clear();
                this.loadedProjectId = null;
                this.loadedSectionId = null;
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            this.UiExceptionHandler.Handle(ex, "Home - ApplySelection");
            this.loadError = "Could not load tasks. Please try again.";
        }
    }

    private async Task LoadProjectTasksAsync(Guid projectId)
    {
        this.activeTasks = await this.TaskOrchestrator.GetByProjectIdAsync(projectId);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks)
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task LoadSectionTasksAsync(Guid sectionId)
    {
        var section = this.AppState.MyTaskFlowSections.FirstOrDefault(item => item.Id == sectionId);
        if (section is null)
        {
            this.activeTasks.Clear();
            this.subTasksByParent.Clear();
            return;
        }

        this.activeTasks = await this.MyTaskFlowSectionOrchestrator.GetSectionTasksAsync(section);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks.Where(x => !x.ParentTaskId.HasValue))
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task OpenEditProjectDialogAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var parameters = new DialogParameters<EditProjectDialog>
        {
            { x => x.ProjectId, this.selectedProject.Id },
            { x => x.InitialName, this.selectedProject.Name },
            { x => x.InitialColor, this.selectedProject.Color },
            { x => x.InitialIcon, this.selectedProject.Icon },
        };

        var dialog = await this.DialogService.ShowAsync<EditProjectDialog>("Edit Project", parameters, new DialogOptions
        {
            CloseOnEscapeKey = true,
            FullWidth = true,
            MaxWidth = MaxWidth.Small,
        });

        await dialog.Result;
        await ReloadAllAsync();
    }

    private async Task OpenDeleteProjectDialogAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var dialog = await this.DialogService.ShowAsync<DeleteProjectDialog>("Delete Project", new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.ExtraSmall,
        });

        var result = await dialog.Result;
        if (!result.Canceled)
        {
            await DeleteProjectAsync();
        }
    }

    private Task OpenBoardTaskDialog(Guid taskId)
    {
        this.selectedTaskId = taskId;
        this.boardTaskId = taskId;
        this.showBoardTaskDialog = true;
        return Task.CompletedTask;
    }

    private void CloseBoardTaskDialog()
    {
        this.showBoardTaskDialog = false;
        this.boardTaskId = null;
    }

    private async Task OpenMoveTaskDialogAsync(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(item => item.Id == taskId);
        if (task is null)
        {
            return;
        }

        var parameters = new DialogParameters<MoveTaskDialog>
        {
            { x => x.CurrentProjectId, task.ProjectId },
            { x => x.Projects, this.AppState.Projects },
        };

        var dialog = await this.DialogService.ShowAsync<MoveTaskDialog>("Move Task", parameters, new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.ExtraSmall,
        });

        var result = await dialog.Result;
        if (!result.Canceled)
        {
            var targetProjectId = result.Data is Guid projectId
                ? projectId
                : (Guid?)null;
            await MoveTaskAsync(task, targetProjectId);
        }
    }

    private async Task HandleBoardDropAsync(TaskBoardView.BoardDropRequest request)
    {
        var task = request.Task;
        var status = request.Status;
        if (task.Status == status)
        {
            return;
        }

        await UpdateStatusAsync(task, status);
    }

    private async Task DeleteProjectAsync()
    {
        if (this.selectedProject is null || this.selectedProject.IsDefault)
        {
            this.Snackbar.Add("Default project cannot be deleted.", Severity.Warning);
            return;
        }

        await this.ProjectOrchestrator.DeleteAsync(this.selectedProject.Id);
        await ReloadAllAsync();
        this.Snackbar.Add("Project deleted.", Severity.Info);
    }

    private async Task CreateTaskAsync()
    {
        if (string.IsNullOrWhiteSpace(this.newTaskTitle))
        {
            return;
        }

        if (this.AppState.SelectedProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(this.AppState.SelectedProjectId.Value, this.newTaskTitle, this.newTaskPriority, string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(this.newTaskTitle, this.newTaskPriority, string.Empty);
        }

        this.newTaskTitle = string.Empty;
        await InvokeAsync(StateHasChanged);
        if (this.newTaskInputRef is not null)
        {
            await this.newTaskInputRef.FocusAsync();
        }

        await ReloadCurrentTasksAsync();
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateTaskInStatusAsync(TaskBoardView.BoardCreateRequest request)
    {
        var status = request.Status;
        var title = request.Title;
        if (string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        TaskFlow.Domain.Task created;
        if (this.AppState.SelectedProjectId.HasValue)
        {
            created = await this.TaskOrchestrator.CreateAsync(this.AppState.SelectedProjectId.Value, title, TaskPriority.Medium, string.Empty);
        }
        else
        {
            created = await this.TaskOrchestrator.CreateUnassignedAsync(title, TaskPriority.Medium, string.Empty);
        }

        if (status != DomainTaskStatus.Todo)
        {
            await this.TaskOrchestrator.SetStatusAsync(created.Id, status);
        }

        await ReloadCurrentTasksAsync();
        await InvokeAsync(StateHasChanged);
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateSubTaskAsync(Guid parentTaskId)
    {
        if (!this.newSubTaskTitles.TryGetValue(parentTaskId, out var title) || string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId, title, TaskPriority.Medium, string.Empty);

        this.newSubTaskTitles[parentTaskId] = string.Empty;
        this.pendingSubTaskFocusParentId = parentTaskId;
        await ReloadCurrentTasksAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleCompleteAsync(TaskFlow.Domain.Task task)
    {
        var target = task.IsCompleted ? DomainTaskStatus.Todo : DomainTaskStatus.Done;
        var previousStatus = task.Status;
        PushUndoAction("toggle completion", async () =>
        {
            await this.TaskOrchestrator.SetStatusAsync(task.Id, previousStatus);
        });

        await this.TaskOrchestrator.SetStatusAsync(task.Id, target);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        var statusMessage = target == DomainTaskStatus.Done ? "Task completed." : "Task restored.";
        this.Snackbar.Add($"{statusMessage} Press Ctrl/Cmd+Z to undo.", Severity.Success);
    }

    private async Task UpdateTitleAsync(TaskFlow.Domain.Task task, string value)
    {
        if (string.Equals(task.Title, value, StringComparison.Ordinal))
        {
            return;
        }

        await this.TaskOrchestrator.UpdateTitleAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateNoteAsync(TaskFlow.Domain.Task task, string value)
    {
        await this.TaskOrchestrator.UpdateNoteAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdatePriorityAsync(TaskFlow.Domain.Task task, TaskPriority priority)
    {
        await this.TaskOrchestrator.SetPriorityAsync(task.Id, priority);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateStatusAsync(TaskFlow.Domain.Task task, DomainTaskStatus status)
    {
        await this.TaskOrchestrator.SetStatusAsync(task.Id, status);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleFocusAsync(TaskFlow.Domain.Task task)
    {
        var wasFocused = task.IsFocused;
        PushUndoAction("toggle focus", async () =>
        {
            var current = this.activeTasks.FirstOrDefault(x => x.Id == task.Id);
            if (current is null || current.IsFocused != wasFocused)
            {
                await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
            }
        });

        await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleImportantAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleImportantAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task DeleteTaskAsync(TaskFlow.Domain.Task task)
    {
        var snapshot = await CaptureTaskSnapshotAsync(task);
        PushUndoAction("delete task", async () =>
        {
            await RestoreTaskSnapshotAsync(snapshot);
        });

        await this.TaskOrchestrator.DeleteAsync(task.Id);
        if (this.boardTaskId == task.Id)
        {
            CloseBoardTaskDialog();
        }
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task deleted. Press Ctrl/Cmd+Z to undo.", Severity.Info);
    }

    private async Task DuplicateTaskAsync(TaskFlow.Domain.Task task)
    {
        var title = $"{task.Title} (Copy)";
        if (task.ProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(task.ProjectId.Value, title, task.Priority, task.Note ?? string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(title, task.Priority, task.Note ?? string.Empty);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task duplicated.", Severity.Info);
    }

    private async Task ToggleTodayMarkAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleTodayMarkAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task MoveTaskAsync(TaskFlow.Domain.Task task, Guid? projectId)
    {
        var previousProjectId = task.ProjectId;
        PushUndoAction("move task", async () =>
        {
            if (previousProjectId.HasValue)
            {
                await this.TaskOrchestrator.MoveToProjectAsync(task.Id, previousProjectId.Value);
            }
            else
            {
                await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
            }
        });

        if (projectId.HasValue)
        {
            await this.TaskOrchestrator.MoveToProjectAsync(task.Id, projectId.Value);
        }
        else
        {
            await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        await RecalculateProjectTaskCountsAsync();
        StateHasChanged();
        this.Snackbar.Add("Task moved.", Severity.Info);
    }

    private async Task ToggleProjectViewAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var next = this.selectedProject.ViewType == ProjectViewType.Board
            ? ProjectViewType.List
            : ProjectViewType.Board;
        await this.ProjectOrchestrator.UpdateViewTypeAsync(this.selectedProject.Id, next);
        await ReloadAllAsync();
    }

    private async Task ClearCompletedAsync()
    {
        var completed = this.activeTasks.Where(task => task.IsCompleted).ToList();
        var completedIds = completed.Select(task => task.Id).ToHashSet();
        var rootCompleted = completed.Where(task => !task.ParentTaskId.HasValue || !completedIds.Contains(task.ParentTaskId.Value)).ToList();
        var snapshots = new List<TaskSnapshot>();
        foreach (var task in rootCompleted)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(task));
        }

        PushUndoAction("clear completed tasks", async () =>
        {
            foreach (var snapshot in snapshots)
            {
                await RestoreTaskSnapshotAsync(snapshot);
            }
        });

        foreach (var task in completed)
        {
            await this.TaskOrchestrator.DeleteAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add($"Cleared {completed.Count} completed task(s). Press Ctrl/Cmd+Z to undo.", Severity.Warning);
    }

    private async Task ReloadCurrentTasksAsync()
    {
        if (this.AppState.SelectedProjectId.HasValue)
        {
            await LoadProjectTasksAsync(this.AppState.SelectedProjectId.Value);
            this.loadedProjectId = this.AppState.SelectedProjectId;
            this.loadedSectionId = null;
            return;
        }

        if (this.AppState.SelectedSectionId.HasValue)
        {
            await LoadSectionTasksAsync(this.AppState.SelectedSectionId.Value);
            this.loadedProjectId = null;
            this.loadedSectionId = this.AppState.SelectedSectionId;
        }
    }

    private List<TaskFlow.Domain.Task> GetBoardTasks(DomainTaskStatus status)
    {
        return this.FilteredTasks.Where(task => task.Status == status).ToList();
    }

    private async Task RecalculateProjectTaskCountsAsync()
    {
        var counts = await BuildProjectTaskCountsAsync(this.AppState.Projects);
        this.AppState.SetProjectTaskCounts(counts);
    }

    private async Task<Dictionary<Guid, int>> BuildProjectTaskCountsAsync(IReadOnlyList<Project> projects)
    {
        var counts = new Dictionary<Guid, int>();
        foreach (var project in projects)
        {
            var projectTasks = await this.TaskOrchestrator.GetByProjectIdAsync(project.Id);
            var count = projectTasks.Count(task => !task.IsCompleted);
            foreach (var task in projectTasks)
            {
                var subtasks = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
                count += subtasks.Count(subTask => !subTask.IsCompleted);
            }

            counts[project.Id] = count;
        }

        return counts;
    }

    private void PushUndoAction(string description, Func<Task> undoAsync)
    {
        if (this.isApplyingUndo)
        {
            return;
        }

        if (this.undoActions.Count >= MaxUndoActions)
        {
            this.undoActions.Clear();
        }

        this.undoActions.Push(new UndoAction(description, undoAsync));
    }

    private async Task UndoLastActionAsync()
    {
        if (!this.undoActions.TryPop(out var action))
        {
            this.Snackbar.Add("Nothing to undo.", Severity.Normal);
            return;
        }

        try
        {
            this.isApplyingUndo = true;
            await action.UndoAsync();
            await ReloadCurrentTasksAsync();
            await RecalculateProjectTaskCountsAsync();
            this.Snackbar.Add($"Undid: {action.Description}", Severity.Success);
        }
        finally
        {
            this.isApplyingUndo = false;
        }
    }

    private async Task<TaskSnapshot> CaptureTaskSnapshotAsync(TaskFlow.Domain.Task task)
    {
        var children = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        var snapshots = new List<TaskSnapshot>();
        foreach (var child in children)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(child));
        }

        return new TaskSnapshot(
            task.Title,
            task.Note ?? string.Empty,
            task.Priority,
            task.Status,
            task.IsFocused,
            task.IsMarkedForToday,
            task.ProjectId,
            snapshots);
    }

    private async Task RestoreTaskSnapshotAsync(TaskSnapshot snapshot, Guid? parentTaskId = null)
    {
        TaskFlow.Domain.Task recreated;
        if (parentTaskId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else if (snapshot.ProjectId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateAsync(snapshot.ProjectId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else
        {
            recreated = await this.TaskOrchestrator.CreateUnassignedAsync(snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }

        if (snapshot.Status != DomainTaskStatus.Todo)
        {
            await this.TaskOrchestrator.SetStatusAsync(recreated.Id, snapshot.Status);
        }

        if (snapshot.IsFocused)
        {
            await this.TaskOrchestrator.ToggleFocusAsync(recreated.Id);
        }

        if (snapshot.IsMarkedForToday)
        {
            await this.TaskOrchestrator.ToggleTodayMarkAsync(recreated.Id);
        }

        foreach (var child in snapshot.Children)
        {
            await RestoreTaskSnapshotAsync(child, recreated.Id);
        }
    }

    private string GetNewSubTaskTitle(Guid parentTaskId)
    {
        return this.newSubTaskTitles.TryGetValue(parentTaskId, out var value) ? value : string.Empty;
    }

    private static string GetSubTaskInputId(Guid parentTaskId)
    {
        return $"subtask-input-{parentTaskId:N}";
    }

    private void SetNewSubTaskTitle(Guid parentTaskId, string value)
    {
        this.newSubTaskTitles[parentTaskId] = value;
    }

    private Task HandleTaskTitleUpdateAsync(TaskEditDialog.TaskStringChange change)
    {
        return UpdateTitleAsync(change.Task, change.Value);
    }

    private Task HandleTaskNoteUpdateAsync(TaskEditDialog.TaskStringChange change)
    {
        return UpdateNoteAsync(change.Task, change.Value);
    }

    private Task HandleTaskPriorityUpdateAsync(TaskEditDialog.TaskPriorityChange change)
    {
        return UpdatePriorityAsync(change.Task, change.Value);
    }

    private Task HandleTaskStatusUpdateAsync(TaskEditDialog.TaskStatusChange change)
    {
        return UpdateStatusAsync(change.Task, change.Value);
    }

    private async Task HandleListTaskTitleUpdateAsync(HomeListView.TitleUpdateRequest request)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == request.TaskId);
        if (task is null)
        {
            return;
        }

        await UpdateTitleAsync(task, request.Title);
    }

    private async Task HandleBoardTaskTitleUpdateAsync(TaskBoardView.TitleUpdateRequest request)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == request.TaskId);
        if (task is null)
        {
            return;
        }

        await UpdateTitleAsync(task, request.Title);
    }

    private async Task HandleCreateTaskKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateTaskAsync();
        }
    }

    private async Task HandleShellKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            if (this.showBoardTaskDialog)
            {
                CloseBoardTaskDialog();
            }
            else if (this.showShortcuts)
            {
                this.showShortcuts = false;
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("Enter", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleCompleteAsync(task);
            }
        }

        if (args.Key == "Delete" && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await DeleteTaskAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("n", StringComparison.OrdinalIgnoreCase))
        {
            if (this.newTaskInputRef is not null)
            {
                await this.newTaskInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("f", StringComparison.OrdinalIgnoreCase))
        {
            if (this.searchInputRef is not null)
            {
                await this.searchInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("p", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleFocusAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("z", StringComparison.OrdinalIgnoreCase))
        {
            await UndoLastActionAsync();
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key == "/")
        {
            ToggleShortcutsHelp();
        }
    }

    private void ToggleShortcutsHelp()
    {
        this.showShortcuts = !this.showShortcuts;
        this.pendingShortcutsFocus = this.showShortcuts;
    }

    [JSInvokable]
    public Task HandleGlobalEscapeAsync()
    {
        if (!this.showBoardTaskDialog && !this.showShortcuts)
        {
            return Task.CompletedTask;
        }

        if (this.showBoardTaskDialog)
        {
            CloseBoardTaskDialog();
        }

        if (this.showShortcuts)
        {
            this.showShortcuts = false;
        }

        return InvokeAsync(StateHasChanged);
    }

    private void HandleShortcutsKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Escape" && this.showShortcuts)
        {
            this.showShortcuts = false;
        }
    }

    public void Dispose()
    {
        this.AppState.Changed -= OnAppStateChanged;
        if (this.escapeHandlerReference is not null)
        {
            _ = this.JsRuntime.InvokeVoidAsync("taskflowUi.unregisterEscapeHandler");
            this.escapeHandlerReference.Dispose();
            this.escapeHandlerReference = null;
        }
    }
}

@if (showBoardTaskDialog && boardTask is not null)
{
    <TaskEditDialog Task="boardTask"
                    SubTasks="(subTasksByParent.TryGetValue(boardTask.Id, out var subTasks) ? subTasks : new List<TaskFlow.Domain.Task>())"
                    BoardStatuses="boardStatuses"
                    OnToggleComplete="ToggleCompleteAsync"
                    OnToggleFocus="ToggleFocusAsync"
                    OnToggleImportant="ToggleImportantAsync"
                    OnUpdateTitle="HandleTaskTitleUpdateAsync"
                    OnUpdateNote="HandleTaskNoteUpdateAsync"
                    OnUpdatePriority="HandleTaskPriorityUpdateAsync"
                    OnUpdateStatus="HandleTaskStatusUpdateAsync"
                    OnToggleToday="ToggleTodayMarkAsync"
                    OnDuplicate="DuplicateTaskAsync"
                    OnDelete="DeleteTaskAsync"
                    OnRequestMove="OpenMoveTaskDialogAsync"
                    NewSubTaskTitle="GetNewSubTaskTitle(boardTask.Id)"
                    OnNewSubTaskTitleChanged="value => SetNewSubTaskTitle(boardTask.Id, value)"
                    OnCreateSubTask="() => CreateSubTaskAsync(boardTask.Id)"
                    OnClose="CloseBoardTaskDialog" />
}
