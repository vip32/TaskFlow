@page "/"
@using Task = System.Threading.Tasks.Task
@using TaskFlow.Domain
@using DomainTaskStatus = TaskFlow.Domain.TaskStatus
@implements IDisposable
@inject IProjectOrchestrator ProjectOrchestrator
@inject ITaskOrchestrator TaskOrchestrator
@inject IMyTaskFlowSectionOrchestrator MyTaskFlowSectionOrchestrator
@inject ISubscriptionSettingsOrchestrator SubscriptionSettingsOrchestrator
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IAppExceptionHandler UiExceptionHandler
@inject IUndoManager UndoManager
@using Microsoft.AspNetCore.Components.Sections

<PageTitle>TaskFlow</PageTitle>

<SectionContent SectionName="AppTopBarTitle">
    <MudStack Class="ml-2" Spacing="0">
        <MudText Typo="Typo.subtitle1">@CurrentTitle</MudText>
        <MudText Typo="Typo.caption">@CurrentSubtitle</MudText>
    </MudStack>
</SectionContent>

<SectionContent SectionName="AppTopBarContent">
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
        <MudTextField @bind-Value="searchQuery"
                      @ref="searchInputRef"
                      Placeholder="Search tasks"
                      Immediate="true"
                      DebounceInterval="150"
                      Variant="Variant.Outlined"
                      Margin="Margin.Dense"
                      Clearable="true"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      Style="min-width: 260px;" />
        <MudHidden Breakpoint="Breakpoint.MdAndDown">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                <MudSelect T="TaskPriority?" @bind-Value="priorityFilter" Label="Priority" Variant="Variant.Outlined" Dense="true" Clearable="true">
                    <MudSelectItem T="TaskPriority?" Value="@TaskPriority.High">High</MudSelectItem>
                    <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Medium">Medium</MudSelectItem>
                    <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Low">Low</MudSelectItem>
                </MudSelect>
                <MudSelect T="DomainTaskStatus?" @bind-Value="statusFilter" Label="Status" Variant="Variant.Outlined" Dense="true" Clearable="true">
                    <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Todo">Todo</MudSelectItem>
                    <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Doing">Doing</MudSelectItem>
                    <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Done">Done</MudSelectItem>
                </MudSelect>
                <MudSelect T="SortMode?" @bind-Value="sortMode" Label="Sort" Variant="Variant.Outlined" Dense="true" Clearable="true">
                    <MudSelectItem T="SortMode?" Value="@SortMode.CreatedDesc">Newest</MudSelectItem>
                    <MudSelectItem T="SortMode?" Value="@SortMode.CreatedAsc">Oldest</MudSelectItem>
                    <MudSelectItem T="SortMode?" Value="@SortMode.Priority">Priority</MudSelectItem>
                    <MudSelectItem T="SortMode?" Value="@SortMode.Focused">Focused</MudSelectItem>
                </MudSelect>
                <MudSwitch @bind-Value="showCompleted"
                           Label="@ShowCompletedLabel"
                           Disabled="alwaysShowCompletedTasks"
                           Color="Color.Primary" />
            </MudStack>
        </MudHidden>
    </MudStack>
</SectionContent>

<SectionContent SectionName="AppTopBarActions">
    <MudTooltip Text="Keyboard shortcuts">
        <MudIconButton Icon="@Icons.Material.Filled.Keyboard"
                       Color="Color.Inherit"
                       aria-label="Open shortcuts"
                       title="Keyboard shortcuts"
                       OnClick="OpenShortcutsDialogAsync" />
    </MudTooltip>
    @if (selectedProject is not null)
    {
        <MudTooltip Text="@ViewToggleTooltip">
            <MudIconButton Icon="@ViewToggleIcon"
                           Color="Color.Inherit"
                           aria-label="Toggle project view"
                           title="@ViewToggleTooltip"
                           OnClick="ToggleProjectViewAsync" />
        </MudTooltip>
    }
</SectionContent>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="py-6" tabindex="0" @onkeydown="HandleShellKeyDown">
    <MudStack Spacing="2">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
            <MudStack Row="true" Spacing="1" Class="flex-wrap">
                <MudTooltip Text="Delete all completed tasks">
                    <MudButton Variant="Variant.Outlined" Color="Color.Warning" OnClick="ClearCompletedAsync">Clear Completed</MudButton>
                </MudTooltip>
                @if (selectedProject is not null)
                {
                    <MudTooltip Text="Edit project">
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" aria-label="Edit project" title="Edit project" OnClick="OpenEditProjectDialogAsync" />
                    </MudTooltip>
                }
            </MudStack>
        </MudStack>

        <MudPaper Elevation="0" Class="pa-3">
            <MudGrid Spacing="2">
                <MudItem xs="12" md="8">
                    <MudTextField @bind-Value="newTaskTitle"
                                  @ref="newTaskInputRef"
                                  Label="Create task"
                                  Variant="Variant.Outlined"
                                  Margin="Margin.Dense"
                                  Immediate="true"
                                  TextUpdateSuppression="false"
                                  OnKeyUp="HandleCreateTaskKeyDown" />
                </MudItem>
                <MudItem xs="8" md="3">
                    <MudSelect T="TaskPriority" @bind-Value="newTaskPriority" Label="Priority" Variant="Variant.Outlined" Dense="true">
                        <MudSelectItem Value="@TaskPriority.High">High</MudSelectItem>
                        <MudSelectItem Value="@TaskPriority.Medium">Medium</MudSelectItem>
                        <MudSelectItem Value="@TaskPriority.Low">Low</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="4" md="1">
                    <MudTooltip Text="Add task">
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" OnClick="CreateTaskAsync">Add</MudButton>
                    </MudTooltip>
                </MudItem>
            </MudGrid>
        </MudPaper>

        @if (isLoading)
        {
            <MudProgressLinear Class="mb-3" Color="Color.Primary" Indeterminate="true" />
        }
        else if (!string.IsNullOrWhiteSpace(loadError))
        {
            <MudAlert Severity="Severity.Error" Dense="true" Class="mb-3">
                @loadError
                <MudButton Variant="Variant.Text" Class="ml-2" OnClick="ReloadAllAsync">Retry</MudButton>
            </MudAlert>
        }
        else if (selectedProject?.ViewType == ProjectViewType.Board)
        {
            <TaskBoardView BoardStatuses="boardStatuses"
                           GetBoardTasks="GetBoardTasks"
                           OnDropTaskToStatus="HandleBoardDropAsync"
                           OnCreateTaskInStatus="CreateTaskInStatusAsync"
                           OnToggleCompleteRequested="HandleTaskToggleCompleteRequestedAsync"
                           OnToggleFocusRequested="HandleTaskToggleFocusRequestedAsync"
                           OnToggleImportantRequested="HandleTaskToggleImportantRequestedAsync"
                           OnToggleTodayRequested="HandleTaskToggleTodayRequestedAsync"
                           OnUpdateTaskTitleRequested="HandleBoardTaskTitleUpdateAsync"
                           OnEditTaskRequested="OpenBoardTaskDialog" />
        }
        else
        {
            <TaskListView Tasks="FilteredTasks"
                          OnToggleCompleteRequested="HandleTaskToggleCompleteRequestedAsync"
                          OnToggleFocusRequested="HandleTaskToggleFocusRequestedAsync"
                          OnToggleImportantRequested="HandleTaskToggleImportantRequestedAsync"
                          OnToggleTodayRequested="HandleTaskToggleTodayRequestedAsync"
                          OnUpdateTaskTitleRequested="HandleListTaskTitleUpdateAsync"
                          OnEditTaskRequested="OpenBoardTaskDialog" />
        }
    </MudStack>
</MudContainer>

@code {
    private enum SortMode
    {
        CreatedDesc,
        CreatedAsc,
        Priority,
        Focused,
    }

    private readonly DomainTaskStatus[] boardStatuses = [DomainTaskStatus.Todo, DomainTaskStatus.Doing, DomainTaskStatus.Done];
    private readonly Dictionary<Guid, List<TaskFlow.Domain.Task>> subTasksByParent = [];
    private List<TaskFlow.Domain.Task> activeTasks = [];
    private Guid? selectedTaskId;
    private string newTaskTitle = string.Empty;
    private TaskPriority newTaskPriority = TaskPriority.Medium;
    private string searchQuery = string.Empty;
    private TaskPriority? priorityFilter;
    private DomainTaskStatus? statusFilter;
    private bool showCompleted;
    private bool alwaysShowCompletedTasks;
    private bool isShortcutsDialogOpen;
    private bool isLoading;
    private SortMode? sortMode = SortMode.CreatedDesc;
    private string loadError;
    private MudTextField<string> newTaskInputRef;
    private MudTextField<string> searchInputRef;
    private Guid? loadedProjectId;
    private Guid? loadedSectionId;

    private sealed record TaskSnapshot(
        string Title,
        string Note,
        TaskPriority Priority,
        DomainTaskStatus Status,
        bool IsFocused,
        bool IsMarkedForToday,
        Guid? ProjectId,
        List<TaskSnapshot> Children);

    private sealed record ProjectSnapshot(
        string Name,
        string Color,
        string Icon,
        ProjectViewType ViewType,
        List<TaskSnapshot> Tasks);

    private Project selectedProject => this.AppState.SelectedProjectId.HasValue
        ? this.AppState.Projects.FirstOrDefault(p => p.Id == this.AppState.SelectedProjectId.Value)
        : null;

    [CascadingParameter]
    public AppState AppState { get; set; } = null!;

    private string CurrentTitle => this.selectedProject?.Name
        ?? this.AppState.MyTaskFlowSections.FirstOrDefault(s => s.Id == this.AppState.SelectedSectionId)?.Name
        ?? "TaskFlow";

    private string CurrentSubtitle => this.selectedProject is null
        ? "Cross-project execution view"
        : $"{FilteredTasks.Count} task(s)";

    private string ViewToggleIcon => this.selectedProject?.ViewType == ProjectViewType.Board
        ? Icons.Material.Filled.ViewList
        : Icons.Material.Filled.ViewKanban;

    private string ViewToggleTooltip => this.selectedProject?.ViewType == ProjectViewType.Board
        ? "Switch to list view"
        : "Switch to board view";

    private string ShowCompletedLabel => this.alwaysShowCompletedTasks ? "Show completed (always on)" : "Show completed";

    private bool ShouldIncludeCompletedTasks => this.alwaysShowCompletedTasks || this.showCompleted;

    private List<TaskFlow.Domain.Task> FilteredTasks => BuildFilteredTasks(includeCompleted: this.ShouldIncludeCompletedTasks);

    private List<TaskFlow.Domain.Task> BoardFilteredTasks => BuildFilteredTasks(includeCompleted: this.ShouldIncludeCompletedTasks);

    protected override async Task OnInitializedAsync()
    {
        this.AppState.Changed += OnAppStateChanged;
        await ReloadAllAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (this.loadedProjectId != this.AppState.SelectedProjectId
            || this.loadedSectionId != this.AppState.SelectedSectionId)
        {
            await ApplySelectionAsync();
            return;
        }
    }

    private async Task ReloadAllAsync()
    {
        this.isLoading = true;
        this.loadError = null;
        try
        {
            var projects = (await this.ProjectOrchestrator.GetAllAsync()).OrderBy(project => project.CreatedAt).ToList();
            var myTaskFlowSections = await this.MyTaskFlowSectionOrchestrator.GetAllAsync();
            var taskCounts = await BuildProjectTaskCountsAsync(projects);
            var settings = await this.SubscriptionSettingsOrchestrator.GetAsync();

            this.AppState.SetNavigationData(projects, myTaskFlowSections, taskCounts);
            this.alwaysShowCompletedTasks = settings.AlwaysShowCompletedTasks;
            this.loadedProjectId = null;
            this.loadedSectionId = null;
            await ApplySelectionAsync();
        }
        catch (Exception ex)
        {
            this.UiExceptionHandler.Handle(ex, "Home - ReloadAll");
            this.loadError = "Could not load data. Please try again.";
        }
        finally
        {
            this.isLoading = false;
        }
    }

    private void OnAppStateChanged()
    {
        _ = InvokeAsync(ApplySelectionAsync);
    }

    private async Task ApplySelectionAsync()
    {
        this.loadError = null;
        if (this.loadedProjectId == this.AppState.SelectedProjectId
            && this.loadedSectionId == this.AppState.SelectedSectionId)
        {
            StateHasChanged();
            return;
        }

        try
        {
            if (this.AppState.SelectedProjectId.HasValue)
            {
                await LoadProjectTasksAsync(this.AppState.SelectedProjectId.Value);
                this.loadedProjectId = this.AppState.SelectedProjectId;
                this.loadedSectionId = null;
            }
            else if (this.AppState.SelectedSectionId.HasValue)
            {
                await LoadSectionTasksAsync(this.AppState.SelectedSectionId.Value);
                this.loadedProjectId = null;
                this.loadedSectionId = this.AppState.SelectedSectionId;
            }
            else
            {
                this.activeTasks.Clear();
                this.subTasksByParent.Clear();
                this.loadedProjectId = null;
                this.loadedSectionId = null;
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            this.UiExceptionHandler.Handle(ex, "Home - ApplySelection");
            this.loadError = "Could not load tasks. Please try again.";
        }
    }

    private async Task LoadProjectTasksAsync(Guid projectId)
    {
        this.activeTasks = await this.TaskOrchestrator.GetByProjectIdAsync(projectId);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks)
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task LoadSectionTasksAsync(Guid sectionId)
    {
        var section = this.AppState.MyTaskFlowSections.FirstOrDefault(item => item.Id == sectionId);
        if (section is null)
        {
            this.activeTasks.Clear();
            this.subTasksByParent.Clear();
            return;
        }

        this.activeTasks = await this.MyTaskFlowSectionOrchestrator.GetSectionTasksAsync(section);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks.Where(x => !x.ParentTaskId.HasValue))
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task OpenEditProjectDialogAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var parameters = new DialogParameters<ProjectEditDialog>
        {
            { x => x.ProjectId, this.selectedProject.Id },
            { x => x.InitialName, this.selectedProject.Name },
            { x => x.InitialColor, this.selectedProject.Color },
            { x => x.InitialIcon, this.selectedProject.Icon },
            { x => x.OnDeleteProject, EventCallback.Factory.Create<Guid>(this, DeleteProjectAsync) },
        };

        var dialog = await this.DialogService.ShowAsync<ProjectEditDialog>("Edit Project", parameters, new DialogOptions
        {
            CloseOnEscapeKey = true,
            FullWidth = true,
            MaxWidth = MaxWidth.Small,
        });

        await dialog.Result;
        await ReloadAllAsync();
    }

    private async Task OpenBoardTaskDialog(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(item => item.Id == taskId);
        if (task is null)
        {
            return;
        }

        this.selectedTaskId = taskId;
        var subTasks = this.subTasksByParent.TryGetValue(task.Id, out var existingSubTasks)
            ? existingSubTasks
            : [];

        var parameters = new DialogParameters<TaskEditDialog>
        {
            { x => x.Task, task },
            { x => x.SubTasks, subTasks },
            { x => x.BoardStatuses, this.boardStatuses },
            { x => x.OnToggleComplete, EventCallback.Factory.Create<TaskFlow.Domain.Task>(this, ToggleCompleteAsync) },
            { x => x.OnToggleFocus, EventCallback.Factory.Create<TaskFlow.Domain.Task>(this, ToggleFocusAsync) },
            { x => x.OnToggleImportant, EventCallback.Factory.Create<TaskFlow.Domain.Task>(this, ToggleImportantAsync) },
            { x => x.OnUpdateTitle, EventCallback.Factory.Create<TaskEditDialog.TaskStringChange>(this, HandleTaskTitleUpdateAsync) },
            { x => x.OnUpdateNote, EventCallback.Factory.Create<TaskEditDialog.TaskStringChange>(this, HandleTaskNoteUpdateAsync) },
            { x => x.OnUpdatePriority, EventCallback.Factory.Create<TaskEditDialog.TaskPriorityChange>(this, HandleTaskPriorityUpdateAsync) },
            { x => x.OnUpdateStatus, EventCallback.Factory.Create<TaskEditDialog.TaskStatusChange>(this, HandleTaskStatusUpdateAsync) },
            { x => x.OnToggleToday, EventCallback.Factory.Create<TaskFlow.Domain.Task>(this, ToggleTodayMarkAsync) },
            { x => x.OnDuplicate, EventCallback.Factory.Create<TaskFlow.Domain.Task>(this, DuplicateTaskAsync) },
            { x => x.OnDelete, EventCallback.Factory.Create<TaskFlow.Domain.Task>(this, DeleteTaskAsync) },
            { x => x.OnRequestMove, EventCallback.Factory.Create<Guid>(this, OpenMoveTaskDialogAsync) },
            { x => x.OnCreateSubTask, EventCallback.Factory.Create<string>(this, title => CreateSubTaskAsync(task.Id, title)) },
        };

        var dialog = await this.DialogService.ShowAsync<TaskEditDialog>("Edit Task", parameters, new DialogOptions
        {
            CloseOnEscapeKey = true,
            FullWidth = true,
            MaxWidth = MaxWidth.Large,
        });

        await dialog.Result;
    }

    private async Task OpenMoveTaskDialogAsync(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(item => item.Id == taskId);
        if (task is null)
        {
            return;
        }

        var parameters = new DialogParameters<TaskMoveDialog>
        {
            { x => x.CurrentProjectId, task.ProjectId },
            { x => x.Projects, this.AppState.Projects },
        };

        var dialog = await this.DialogService.ShowAsync<TaskMoveDialog>("Move Task", parameters, new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.ExtraSmall,
        });

        var result = await dialog.Result;
        if (!result.Canceled)
        {
            var targetProjectId = result.Data is Guid projectId
                ? projectId
                : (Guid?)null;
            await MoveTaskAsync(task, targetProjectId);
        }
    }

    private async Task HandleBoardDropAsync(TaskBoardView.BoardDropRequest request)
    {
        var task = request.Task;
        var status = request.Status;
        if (task.Status == status)
        {
            return;
        }

        await UpdateStatusAsync(task, status);
    }

    private async Task DeleteProjectAsync(Guid projectId)
    {
        var project = this.AppState.Projects.FirstOrDefault(p => p.Id == projectId);
        if (project is null || project.IsDefault)
        {
            this.Snackbar.Add("Default project cannot be deleted.", Severity.Warning);
            return;
        }

        var taskSnapshots = new List<TaskSnapshot>();
        var projectTasks = await this.TaskOrchestrator.GetByProjectIdAsync(projectId);
        foreach (var task in projectTasks)
        {
            taskSnapshots.Add(await CaptureTaskSnapshotAsync(task));
        }

        var projectSnapshot = new ProjectSnapshot(
            project.Name,
            project.Color,
            project.Icon,
            project.ViewType,
            taskSnapshots);

        this.UndoManager.Register("delete project", async () =>
        {
            await RestoreProjectSnapshotAsync(projectSnapshot);
        });

        await this.ProjectOrchestrator.DeleteAsync(projectId);
        await ReloadAllAsync();
        ShowUndoSnackbar("Project deleted.", Severity.Info);
    }

    private async Task CreateTaskAsync()
    {
        if (string.IsNullOrWhiteSpace(this.newTaskTitle))
        {
            return;
        }

        if (this.AppState.SelectedProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(this.AppState.SelectedProjectId.Value, this.newTaskTitle, this.newTaskPriority, string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(this.newTaskTitle, this.newTaskPriority, string.Empty);
        }

        this.newTaskTitle = string.Empty;
        await InvokeAsync(StateHasChanged);
        if (this.newTaskInputRef is not null)
        {
            await this.newTaskInputRef.FocusAsync();
        }

        await ReloadCurrentTasksAsync();
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateTaskInStatusAsync(TaskBoardView.BoardCreateRequest request)
    {
        var status = request.Status;
        var title = request.Title;
        if (string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        TaskFlow.Domain.Task created;
        if (this.AppState.SelectedProjectId.HasValue)
        {
            created = await this.TaskOrchestrator.CreateAsync(this.AppState.SelectedProjectId.Value, title, TaskPriority.Medium, string.Empty);
        }
        else
        {
            created = await this.TaskOrchestrator.CreateUnassignedAsync(title, TaskPriority.Medium, string.Empty);
        }

        if (status != DomainTaskStatus.Todo)
        {
            await this.TaskOrchestrator.SetStatusAsync(created.Id, status);
        }

        await ReloadCurrentTasksAsync();
        await InvokeAsync(StateHasChanged);
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateSubTaskAsync(Guid parentTaskId, string title)
    {
        if (string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId, title, TaskPriority.Medium, string.Empty);
        await ReloadCurrentTasksAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleCompleteAsync(TaskFlow.Domain.Task task)
    {
        var target = !task.IsCompleted;
        var previous = task.IsCompleted;
        this.UndoManager.Register("toggle completion", async () =>
        {
            await this.TaskOrchestrator.SetCompletedAsync(task.Id, previous);
        });

        await this.TaskOrchestrator.SetCompletedAsync(task.Id, target);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        var statusMessage = target ? "Task completed." : "Task restored.";
        ShowUndoSnackbar(statusMessage, Severity.Success);
    }

    private async Task UpdateTitleAsync(TaskFlow.Domain.Task task, string value)
    {
        if (string.Equals(task.Title, value, StringComparison.Ordinal))
        {
            return;
        }

        await this.TaskOrchestrator.UpdateTitleAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateNoteAsync(TaskFlow.Domain.Task task, string value)
    {
        await this.TaskOrchestrator.UpdateNoteAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdatePriorityAsync(TaskFlow.Domain.Task task, TaskPriority priority)
    {
        await this.TaskOrchestrator.SetPriorityAsync(task.Id, priority);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateStatusAsync(TaskFlow.Domain.Task task, DomainTaskStatus status)
    {
        await this.TaskOrchestrator.SetStatusAsync(task.Id, status);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleFocusAsync(TaskFlow.Domain.Task task)
    {
        var wasFocused = task.IsFocused;
        this.UndoManager.Register("toggle focus", async () =>
        {
            var current = this.activeTasks.FirstOrDefault(x => x.Id == task.Id);
            if (current is null || current.IsFocused != wasFocused)
            {
                await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
            }
        });

        await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleImportantAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleImportantAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task DeleteTaskAsync(TaskFlow.Domain.Task task)
    {
        var snapshot = await CaptureTaskSnapshotAsync(task);
        this.UndoManager.Register("delete task", async () =>
        {
            await RestoreTaskSnapshotAsync(snapshot);
        });

        await this.TaskOrchestrator.DeleteAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        ShowUndoSnackbar("Task deleted.", Severity.Info);
    }

    private async Task DuplicateTaskAsync(TaskFlow.Domain.Task task)
    {
        var title = $"{task.Title} (Copy)";
        if (task.ProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(task.ProjectId.Value, title, task.Priority, task.Note ?? string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(title, task.Priority, task.Note ?? string.Empty);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task duplicated.", Severity.Info);
    }

    private async Task ToggleTodayMarkAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleTodayMarkAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task MoveTaskAsync(TaskFlow.Domain.Task task, Guid? projectId)
    {
        var previousProjectId = task.ProjectId;
        this.UndoManager.Register("move task", async () =>
        {
            if (previousProjectId.HasValue)
            {
                await this.TaskOrchestrator.MoveToProjectAsync(task.Id, previousProjectId.Value);
            }
            else
            {
                await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
            }
        });

        if (projectId.HasValue)
        {
            await this.TaskOrchestrator.MoveToProjectAsync(task.Id, projectId.Value);
        }
        else
        {
            await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        await RecalculateProjectTaskCountsAsync();
        StateHasChanged();
        this.Snackbar.Add("Task moved.", Severity.Info);
    }

    private async Task ToggleProjectViewAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var next = this.selectedProject.ViewType == ProjectViewType.Board
            ? ProjectViewType.List
            : ProjectViewType.Board;
        await this.ProjectOrchestrator.UpdateViewTypeAsync(this.selectedProject.Id, next);
        await ReloadAllAsync();
    }

    private async Task ClearCompletedAsync()
    {
        var completed = this.activeTasks.Where(task => task.IsCompleted).ToList();
        var completedIds = completed.Select(task => task.Id).ToHashSet();
        var rootCompleted = completed.Where(task => !task.ParentTaskId.HasValue || !completedIds.Contains(task.ParentTaskId.Value)).ToList();
        var snapshots = new List<TaskSnapshot>();
        foreach (var task in rootCompleted)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(task));
        }

        this.UndoManager.Register("clear completed tasks", async () =>
        {
            foreach (var snapshot in snapshots)
            {
                await RestoreTaskSnapshotAsync(snapshot);
            }
        });

        foreach (var task in completed)
        {
            await this.TaskOrchestrator.DeleteAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        ShowUndoSnackbar($"Cleared {completed.Count} completed task(s).", Severity.Warning);
    }

    private async Task ReloadCurrentTasksAsync()
    {
        if (this.AppState.SelectedProjectId.HasValue)
        {
            await LoadProjectTasksAsync(this.AppState.SelectedProjectId.Value);
            this.loadedProjectId = this.AppState.SelectedProjectId;
            this.loadedSectionId = null;
            return;
        }

        if (this.AppState.SelectedSectionId.HasValue)
        {
            await LoadSectionTasksAsync(this.AppState.SelectedSectionId.Value);
            this.loadedProjectId = null;
            this.loadedSectionId = this.AppState.SelectedSectionId;
        }
    }

    private List<TaskFlow.Domain.Task> GetBoardTasks(DomainTaskStatus status)
    {
        return this.BoardFilteredTasks.Where(task => task.Status == status).ToList();
    }

    private List<TaskFlow.Domain.Task> BuildFilteredTasks(bool includeCompleted)
    {
        IEnumerable<TaskFlow.Domain.Task> query = this.activeTasks;

        if (!string.IsNullOrWhiteSpace(this.searchQuery))
        {
            var normalized = this.searchQuery.Trim();
            query = query.Where(task =>
                task.Title.Contains(normalized, StringComparison.OrdinalIgnoreCase)
                || (task.Note?.Contains(normalized, StringComparison.OrdinalIgnoreCase) ?? false));
        }

        if (this.priorityFilter.HasValue)
        {
            query = query.Where(task => task.Priority == this.priorityFilter.Value);
        }

        if (this.statusFilter.HasValue)
        {
            query = query.Where(task => task.Status == this.statusFilter.Value);
        }

        if (!includeCompleted)
        {
            query = query.Where(task => !task.IsCompleted);
        }

        query = (this.sortMode ?? SortMode.CreatedDesc) switch
        {
            SortMode.CreatedAsc => query.OrderBy(task => task.IsCompleted).ThenByDescending(task => task.IsFocused).ThenBy(task => task.CreatedAt),
            SortMode.Priority => query.OrderBy(task => task.IsCompleted).ThenByDescending(task => task.IsFocused).ThenByDescending(task => task.Priority).ThenByDescending(task => task.CreatedAt),
            SortMode.Focused => query.Where(task => task.IsFocused).OrderBy(task => task.IsCompleted).ThenByDescending(task => task.CreatedAt),
            _ => query.OrderBy(task => task.IsCompleted).ThenByDescending(task => task.IsFocused).ThenByDescending(task => task.CreatedAt),
        };

        return query.Where(task => !task.ParentTaskId.HasValue).ToList();
    }

    private async Task RecalculateProjectTaskCountsAsync()
    {
        var counts = await BuildProjectTaskCountsAsync(this.AppState.Projects);
        this.AppState.SetProjectTaskCounts(counts);
    }

    private async Task<Dictionary<Guid, int>> BuildProjectTaskCountsAsync(IReadOnlyList<Project> projects)
    {
        var counts = new Dictionary<Guid, int>();
        foreach (var project in projects)
        {
            var projectTasks = await this.TaskOrchestrator.GetByProjectIdAsync(project.Id);
            var count = projectTasks.Count(task => !task.IsCompleted);
            foreach (var task in projectTasks)
            {
                var subtasks = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
                count += subtasks.Count(subTask => !subTask.IsCompleted);
            }

            counts[project.Id] = count;
        }

        return counts;
    }

    private async Task UndoLastActionAsync()
    {
        var undoResult = await this.UndoManager.UndoAsync();
        if (!undoResult.HasAction)
        {
            this.Snackbar.Add("Nothing to undo.", Severity.Normal);
            return;
        }

        await ReloadAllAsync();
        this.Snackbar.Add($"Undid: {undoResult.Description}", Severity.Success);
    }

    private void ShowUndoSnackbar(string message, Severity severity)
    {
        this.Snackbar.Add(message, severity, options =>
        {
            options.Action = "Undo";
            options.ActionColor = Color.Primary;
            options.OnClick = _ => UndoLastActionAsync();
        });
    }

    private async Task<TaskSnapshot> CaptureTaskSnapshotAsync(TaskFlow.Domain.Task task)
    {
        var children = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        var snapshots = new List<TaskSnapshot>();
        foreach (var child in children)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(child));
        }

        return new TaskSnapshot(
            task.Title,
            task.Note ?? string.Empty,
            task.Priority,
            task.Status,
            task.IsFocused,
            task.IsMarkedForToday,
            task.ProjectId,
            snapshots);
    }

    private async Task RestoreTaskSnapshotAsync(TaskSnapshot snapshot, Guid? parentTaskId = null, Guid? overrideProjectId = null)
    {
        TaskFlow.Domain.Task recreated;
        if (parentTaskId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else if (overrideProjectId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateAsync(overrideProjectId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else if (snapshot.ProjectId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateAsync(snapshot.ProjectId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else
        {
            recreated = await this.TaskOrchestrator.CreateUnassignedAsync(snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }

        if (snapshot.Status != DomainTaskStatus.Todo)
        {
            await this.TaskOrchestrator.SetStatusAsync(recreated.Id, snapshot.Status);
        }

        if (snapshot.IsFocused)
        {
            await this.TaskOrchestrator.ToggleFocusAsync(recreated.Id);
        }

        if (snapshot.IsMarkedForToday)
        {
            await this.TaskOrchestrator.ToggleTodayMarkAsync(recreated.Id);
        }

        foreach (var child in snapshot.Children)
        {
            await RestoreTaskSnapshotAsync(child, recreated.Id, overrideProjectId);
        }
    }

    private async Task RestoreProjectSnapshotAsync(ProjectSnapshot snapshot)
    {
        var restoredProject = await this.ProjectOrchestrator.CreateAsync(snapshot.Name, snapshot.Color, snapshot.Icon);
        if (restoredProject.ViewType != snapshot.ViewType)
        {
            await this.ProjectOrchestrator.UpdateViewTypeAsync(restoredProject.Id, snapshot.ViewType);
        }

        foreach (var taskSnapshot in snapshot.Tasks)
        {
            await RestoreTaskSnapshotAsync(taskSnapshot, parentTaskId: null, overrideProjectId: restoredProject.Id);
        }
    }

    private Task HandleTaskTitleUpdateAsync(TaskEditDialog.TaskStringChange change)
    {
        return UpdateTitleAsync(change.Task, change.Value);
    }

    private Task HandleTaskNoteUpdateAsync(TaskEditDialog.TaskStringChange change)
    {
        return UpdateNoteAsync(change.Task, change.Value);
    }

    private Task HandleTaskPriorityUpdateAsync(TaskEditDialog.TaskPriorityChange change)
    {
        return UpdatePriorityAsync(change.Task, change.Value);
    }

    private Task HandleTaskStatusUpdateAsync(TaskEditDialog.TaskStatusChange change)
    {
        return UpdateStatusAsync(change.Task, change.Value);
    }

    private async Task HandleListTaskTitleUpdateAsync(TaskListView.TitleUpdateRequest request)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == request.TaskId);
        if (task is null)
        {
            return;
        }

        await UpdateTitleAsync(task, request.Title);
    }

    private async Task HandleBoardTaskTitleUpdateAsync(TaskBoardView.TitleUpdateRequest request)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == request.TaskId);
        if (task is null)
        {
            return;
        }

        await UpdateTitleAsync(task, request.Title);
    }

    private async Task HandleTaskToggleCompleteRequestedAsync(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == taskId);
        if (task is null)
        {
            return;
        }

        await ToggleCompleteAsync(task);
    }

    private async Task HandleTaskToggleFocusRequestedAsync(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == taskId);
        if (task is null)
        {
            return;
        }

        await ToggleFocusAsync(task);
    }

    private async Task HandleTaskToggleImportantRequestedAsync(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == taskId);
        if (task is null)
        {
            return;
        }

        await ToggleImportantAsync(task);
    }

    private async Task HandleTaskToggleTodayRequestedAsync(Guid taskId)
    {
        var task = this.activeTasks.FirstOrDefault(x => x.Id == taskId);
        if (task is null)
        {
            return;
        }

        await ToggleTodayMarkAsync(task);
    }

    private async Task HandleCreateTaskKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateTaskAsync();
        }
    }

    private async Task HandleShellKeyDown(KeyboardEventArgs args)
    {
        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("Enter", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleCompleteAsync(task);
            }
        }

        if (args.Key == "Delete" && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await DeleteTaskAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("n", StringComparison.OrdinalIgnoreCase))
        {
            if (this.newTaskInputRef is not null)
            {
                await this.newTaskInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("f", StringComparison.OrdinalIgnoreCase))
        {
            if (this.searchInputRef is not null)
            {
                await this.searchInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("p", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleFocusAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("z", StringComparison.OrdinalIgnoreCase))
        {
            await UndoLastActionAsync();
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key == "/")
        {
            await OpenShortcutsDialogAsync();
        }
    }

    private async Task OpenShortcutsDialogAsync()
    {
        if (this.isShortcutsDialogOpen)
        {
            return;
        }

        try
        {
            this.isShortcutsDialogOpen = true;
            var dialog = await this.DialogService.ShowAsync<ShortcutsDialog>("Keyboard shortcuts", new DialogOptions
            {
                CloseOnEscapeKey = true,
                MaxWidth = MaxWidth.Small,
                FullWidth = true,
            });
            await dialog.Result;
        }
        finally
        {
            this.isShortcutsDialogOpen = false;
        }
    }

    public void Dispose()
    {
        this.AppState.Changed -= OnAppStateChanged;
    }
}

