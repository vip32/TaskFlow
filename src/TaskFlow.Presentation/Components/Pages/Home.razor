@page "/"
@using Task = System.Threading.Tasks.Task
@using TaskFlow.Domain
@using DomainTaskStatus = TaskFlow.Domain.TaskStatus
@inject IProjectOrchestrator ProjectOrchestrator
@inject ITaskOrchestrator TaskOrchestrator
@inject IMyTaskFlowSectionOrchestrator MyTaskFlowSectionOrchestrator
@inject ISnackbar Snackbar
@inject IJSRuntime JsRuntime

<PageTitle>TaskFlow</PageTitle>

<div class="@ShellClass" tabindex="0" @onkeydown="HandleShellKeyDown">
    <aside class="@SidebarClass">
        <div class="tf-brand">
            <MudIcon Icon="@Icons.Material.Filled.Widgets" Size="Size.Medium" />
            <div>
                <div class="tf-brand-title">TaskFlow</div>
                <div class="tf-brand-subtitle">Execution First</div>
            </div>
        </div>

        @if (!isSidebarCollapsed)
        {
            <MudText Typo="Typo.caption" Class="tf-sidebar-caption">My Task Flow</MudText>
        }
        @foreach (var flowSection in myTaskFlowSections)
        {
            var isActive = selectedSectionId == flowSection.Id;
            <MudButton FullWidth="true"
                       Variant="@(isActive ? Variant.Filled : Variant.Text)"
                       Color="@(isActive ? Color.Primary : Color.Default)"
                       Class="tf-sidebar-button"
                       OnClick="() => SelectSectionAsync(flowSection.Id)">
                @if (!isSidebarCollapsed)
                {
                    @flowSection.Name
                }
            </MudButton>
        }

        @if (!isSidebarCollapsed)
        {
            <MudDivider Class="my-4" />
        }

        @if (!isSidebarCollapsed)
        {
            <MudText Typo="Typo.caption" Class="tf-sidebar-caption">Projects</MudText>
        }
        @foreach (var project in projects)
        {
            var isActive = selectedProjectId == project.Id;
            <MudButton FullWidth="true"
                       Variant="@(isActive ? Variant.Filled : Variant.Text)"
                       Color="@(isActive ? Color.Primary : Color.Default)"
                       Class="tf-sidebar-button"
                       OnClick="() => SelectProjectAsync(project.Id)">
                <MudIcon Icon="@ResolveProjectIcon(project.Icon)" Size="Size.Small" Class="mr-2" />
                <span class="tf-project-dot" style="@($"background:{project.Color};")"></span>
                @if (!isSidebarCollapsed)
                {
                    <span class="tf-project-name">@project.Name</span>
                    <MudBadge Class="tf-project-count" Color="Color.Info" Content="@GetProjectTaskCount(project.Id)" />
                }
            </MudButton>
        }

        @if (!isSidebarCollapsed)
        {
            <MudStack Row="true" AlignItems="AlignItems.Center" Class="mt-3" Spacing="1">
                <MudTextField @bind-Value="newProjectName"
                              Variant="Variant.Outlined"
                              Margin="Margin.Dense"
                              Immediate="true"
                              Placeholder="New project"
                              Class="tf-sidebar-input"
                              OnKeyDown="HandleCreateProjectKeyDown" />
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateProjectAsync">Create</MudButton>
            </MudStack>
        }
    </aside>

    <section class="tf-main">
        <header class="tf-toolbar">
            <div>
                <MudText Typo="Typo.h5">@CurrentTitle</MudText>
                <MudText Typo="Typo.caption">@CurrentSubtitle</MudText>
            </div>
            <MudStack Row="true" Spacing="1">
                <MudTooltip Text="Collapse/expand sidebar">
                    <MudIconButton Icon="@(isSidebarCollapsed ? Icons.Material.Filled.MenuOpen : Icons.Material.Filled.Menu)" OnClick="ToggleSidebarCollapse" />
                </MudTooltip>
                <MudTooltip Text="Keyboard shortcuts">
                    <MudButton Variant="Variant.Outlined" OnClick="ToggleShortcutsHelp">Shortcuts</MudButton>
                </MudTooltip>
                <MudTooltip Text="Toggle light/dark mode">
                    <MudIconButton Icon="@(IsDarkMode ? Icons.Material.Filled.DarkMode : Icons.Material.Filled.LightMode)" OnClick="ToggleThemeAsync" />
                </MudTooltip>
                @if (selectedProject is not null)
                {
                    <MudTooltip Text="Toggle list/board view">
                        <MudButton Variant="Variant.Outlined" OnClick="ToggleProjectViewAsync">@ViewToggleLabel</MudButton>
                    </MudTooltip>
                    <MudTooltip Text="Edit project">
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" OnClick="OpenEditProjectDialog" />
                    </MudTooltip>
                    <MudTooltip Text="Delete project">
                        <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="OpenDeleteProjectDialog">Delete Project</MudButton>
                    </MudTooltip>
                }
            </MudStack>
        </header>

        <MudPaper Class="tf-filters" Elevation="0">
            <MudTextField @bind-Value="searchQuery"
                          @ref="searchInputRef"
                          Placeholder="Search tasks"
                          Immediate="true"
                          DebounceInterval="150"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search" />
            <MudSelect T="TaskPriority?" @bind-Value="priorityFilter" Label="Priority" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem T="TaskPriority?" Value="null">All</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.High">High</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Medium">Medium</MudSelectItem>
                <MudSelectItem T="TaskPriority?" Value="@TaskPriority.Low">Low</MudSelectItem>
            </MudSelect>
            <MudSelect T="DomainTaskStatus?" @bind-Value="statusFilter" Label="Status" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem T="DomainTaskStatus?" Value="null">All</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.New">New</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.InProgress">In Progress</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Paused">Paused</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Done">Done</MudSelectItem>
                <MudSelectItem T="DomainTaskStatus?" Value="@DomainTaskStatus.Cancelled">Cancelled</MudSelectItem>
            </MudSelect>
            <MudSelect T="SortMode" @bind-Value="sortMode" Label="Sort" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@SortMode.CreatedDesc">Newest</MudSelectItem>
                <MudSelectItem Value="@SortMode.CreatedAsc">Oldest</MudSelectItem>
                <MudSelectItem Value="@SortMode.Priority">Priority</MudSelectItem>
                <MudSelectItem Value="@SortMode.Focused">Focused</MudSelectItem>
            </MudSelect>
            <MudSwitch @bind-Value="showCompleted" Label="Show completed" Color="Color.Primary" />
            <MudTooltip Text="Delete all completed tasks">
                <MudButton Variant="Variant.Outlined" Color="Color.Warning" OnClick="ClearCompletedAsync">Clear Completed</MudButton>
            </MudTooltip>
        </MudPaper>

        <MudPaper Class="tf-create-row" Elevation="0">
            <MudTextField @bind-Value="newTaskTitle"
                          @ref="newTaskInputRef"
                          Label="Create task"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Immediate="true"
                          TextUpdateSuppression="false"
                          OnKeyUp="HandleCreateTaskKeyDown" />
            <MudSelect T="TaskPriority" @bind-Value="newTaskPriority" Label="Priority" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@TaskPriority.High">High</MudSelectItem>
                <MudSelectItem Value="@TaskPriority.Medium">Medium</MudSelectItem>
                <MudSelectItem Value="@TaskPriority.Low">Low</MudSelectItem>
            </MudSelect>
            <MudTooltip Text="Add task">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateTaskAsync">Add</MudButton>
            </MudTooltip>
        </MudPaper>

        @if (selectedProject?.ViewType == ProjectViewType.Board)
        {
            <div class="tf-board">
                @foreach (var status in boardStatuses)
                {
                    <MudPaper Class="tf-board-column" Elevation="0">
                        <MudText Typo="Typo.subtitle2">@status (@GetBoardTasks(status).Count)</MudText>
                        @foreach (var task in GetBoardTasks(status))
                        {
                            <MudPaper Class="@GetTaskContainerClass(task, false)" Elevation="1" @onclick="() => selectedTaskId = task.Id">
                                <TaskCard Item="task"
                                          BoardStatuses="boardStatuses"
                                          OnToggleComplete="() => ToggleCompleteAsync(task)"
                                          OnToggleFocus="() => ToggleFocusAsync(task)"
                                          OnUpdateTitle="value => UpdateTitleAsync(task, value)"
                                          OnUpdateNote="value => UpdateNoteAsync(task, value)"
                                          OnUpdatePriority="value => UpdatePriorityAsync(task, value)"
                                          OnUpdateStatus="value => UpdateStatusAsync(task, value)"
                                          OnToggleToday="() => ToggleTodayMarkAsync(task)"
                                          OnDuplicate="() => DuplicateTaskAsync(task)"
                                          OnDelete="() => DeleteTaskAsync(task)"
                                          OnRequestMove="() => OpenMoveTaskDialog(task.Id)" />
                            </MudPaper>
                        }
                    </MudPaper>
                }
            </div>
        }
        else
        {
            <div class="tf-list">
                @if (FilteredTasks.Count == 0)
                {
                    <MudPaper Class="tf-empty" Elevation="0">
                        <MudText Typo="Typo.h6">No tasks yet</MudText>
                        <MudText Typo="Typo.body2">Create your first task and keep momentum going.</MudText>
                    </MudPaper>
                }
                else
                {
                    @foreach (var task in FilteredTasks)
                    {
                        <MudPaper Class="@GetTaskContainerClass(task, false)" Elevation="0" @onclick="() => selectedTaskId = task.Id">
                            <TaskCard Item="task"
                                      BoardStatuses="boardStatuses"
                                      OnToggleComplete="() => ToggleCompleteAsync(task)"
                                      OnToggleFocus="() => ToggleFocusAsync(task)"
                                      OnUpdateTitle="value => UpdateTitleAsync(task, value)"
                                      OnUpdateNote="value => UpdateNoteAsync(task, value)"
                                      OnUpdatePriority="value => UpdatePriorityAsync(task, value)"
                                      OnUpdateStatus="value => UpdateStatusAsync(task, value)"
                                      OnToggleToday="() => ToggleTodayMarkAsync(task)"
                                      OnDuplicate="() => DuplicateTaskAsync(task)"
                                      OnDelete="() => DeleteTaskAsync(task)"
                                      OnRequestMove="() => OpenMoveTaskDialog(task.Id)" />

                            @if (subTasksByParent.TryGetValue(task.Id, out var subTasks) && subTasks.Count > 0)
                            {
                                <div class="tf-subtasks">
                                    @foreach (var subTask in subTasks)
                                    {
                                        <MudPaper Class="@GetTaskContainerClass(subTask, true)" Elevation="0">
                                            <TaskCard Item="subTask"
                                                      BoardStatuses="boardStatuses"
                                                      OnToggleComplete="() => ToggleCompleteAsync(subTask)"
                                                      OnToggleFocus="() => ToggleFocusAsync(subTask)"
                                                      OnUpdateTitle="value => UpdateTitleAsync(subTask, value)"
                                                      OnUpdateNote="value => UpdateNoteAsync(subTask, value)"
                                                      OnUpdatePriority="value => UpdatePriorityAsync(subTask, value)"
                                                      OnUpdateStatus="value => UpdateStatusAsync(subTask, value)"
                                                      OnToggleToday="() => ToggleTodayMarkAsync(subTask)"
                                                      OnDuplicate="() => DuplicateTaskAsync(subTask)"
                                                      OnDelete="() => DeleteTaskAsync(subTask)"
                                                      OnRequestMove="() => OpenMoveTaskDialog(subTask.Id)" />
                                        </MudPaper>
                                    }
                                </div>
                            }

                            <MudStack Row="true" Class="mt-2" Spacing="1">
                                <MudTextField T="string" Value="@GetNewSubTaskTitle(task.Id)"
                                              ValueChanged="value => SetNewSubTaskTitle(task.Id, value)"
                                              Placeholder="Add subtask"
                                              Variant="Variant.Text"
                                              Margin="Margin.Dense"
                                              TextUpdateSuppression="false"
                                              InputId="@GetSubTaskInputId(task.Id)"
                                              OnKeyUp="args => HandleCreateSubTaskKeyUp(task.Id, args)"
                                              Class="tf-subtask-input" />
                                <MudTooltip Text="Add subtask">
                                    <MudIconButton Icon="@Icons.Material.Filled.SubdirectoryArrowRight" OnClick="() => CreateSubTaskAsync(task.Id)" />
                                </MudTooltip>
                            </MudStack>
                        </MudPaper>
                    }
                }
            </div>
        }

        <MudPaper Class="tf-focus-timer" Elevation="0">
            <MudText Typo="Typo.subtitle2">Focus Timer</MudText>
            <MudText Typo="Typo.h6">@timerRemaining.ToString(@"mm\:ss")</MudText>
            <MudSelect T="int" Value="selectedTimerMinutes" ValueChanged="OnTimerPresetChangedAsync" Label="Duration" Dense="true" Variant="Variant.Outlined">
                <MudSelectItem Value="5">5 mins</MudSelectItem>
                <MudSelectItem Value="15">15 mins</MudSelectItem>
                <MudSelectItem Value="30">30 mins</MudSelectItem>
                <MudSelectItem Value="60">60 mins</MudSelectItem>
            </MudSelect>
            <MudStack Row="true" Spacing="1">
                <MudTooltip Text="Start focus timer">
                    <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="StartTimer" Disabled="@timerRunning">Start</MudButton>
                </MudTooltip>
                <MudTooltip Text="Pause focus timer">
                    <MudButton Variant="Variant.Outlined" OnClick="PauseTimer" Disabled="@(!timerRunning)">Pause</MudButton>
                </MudTooltip>
                <MudTooltip Text="Reset focus timer">
                    <MudButton Variant="Variant.Text" OnClick="ResetTimer">Reset</MudButton>
                </MudTooltip>
            </MudStack>
        </MudPaper>
    </section>
</div>

@if (showShortcuts)
{
    <div class="tf-shortcuts-backdrop" @onclick="ToggleShortcutsHelp">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Keyboard shortcuts</MudText>
            <p>Ctrl/Cmd + Enter: complete selected task</p>
            <p>Delete: delete selected task</p>
            <p>Ctrl/Cmd + N: focus new task</p>
            <p>Ctrl/Cmd + F: focus search</p>
            <p>Ctrl/Cmd + P: toggle focus pin on selected task</p>
            <p>Ctrl/Cmd + Z: undo last action</p>
            <p>Ctrl/Cmd + /: toggle this help</p>
        </MudPaper>
    </div>
}

@if (showDeleteProjectDialog)
{
    <div class="tf-shortcuts-backdrop" @onclick="CloseDeleteProjectDialog">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Delete this project?</MudText>
            <p>This will remove the project and its tasks.</p>
            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Outlined" OnClick="CloseDeleteProjectDialog">Cancel</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="DeleteProjectAsync">Delete</MudButton>
            </MudStack>
        </MudPaper>
    </div>
}

@code {
    private const int MaxUndoActions = 20;

    private enum SortMode
    {
        CreatedDesc,
        CreatedAsc,
        Priority,
        Focused,
    }

    private readonly DomainTaskStatus[] boardStatuses = [DomainTaskStatus.New, DomainTaskStatus.InProgress, DomainTaskStatus.Paused, DomainTaskStatus.Done, DomainTaskStatus.Cancelled];
    private readonly Dictionary<Guid, List<TaskFlow.Domain.Task>> subTasksByParent = [];
    private readonly Dictionary<Guid, string> newSubTaskTitles = [];
    private readonly Dictionary<Guid, int> projectTaskCounts = [];
    private readonly Stack<UndoAction> undoActions = new();
    private readonly (string Hex, string Name)[] projectColorOptions =
    [
        ("#2D9CFF", "Ocean Blue"),
        ("#30C76A", "Mint Green"),
        ("#F2B01E", "Amber"),
        ("#EF4B6C", "Coral Red"),
        ("#9B5DE5", "Violet"),
        ("#14B8A6", "Teal"),
        ("#F97316", "Orange"),
        ("#64748B", "Slate"),
    ];

    private List<Project> projects = [];
    private List<MyTaskFlowSection> myTaskFlowSections = [];
    private List<TaskFlow.Domain.Task> activeTasks = [];
    private Guid? selectedProjectId;
    private Guid? selectedSectionId;
    private Guid? selectedTaskId;
    private string newProjectName = string.Empty;
    private string editProjectName = string.Empty;
    private string editProjectColor = "#2D9CFF";
    private string editProjectIcon = "folder";
    private string newTaskTitle = string.Empty;
    private TaskPriority newTaskPriority = TaskPriority.Medium;
    private string searchQuery = string.Empty;
    private TaskPriority? priorityFilter;
    private DomainTaskStatus? statusFilter;
    private bool showCompleted;
    private bool showShortcuts;
    private bool showDeleteProjectDialog;
    private bool showEditProjectDialog;
    private bool showMoveTaskDialog;
    private bool isApplyingUndo;
    private bool isSidebarCollapsed;
    private SortMode sortMode = SortMode.CreatedDesc;
    private int selectedTimerMinutes = 30;
    private TimeSpan timerRemaining = TimeSpan.FromMinutes(30);
    private bool timerRunning;
    private PeriodicTimer timer = null!;
    private CancellationTokenSource timerCts = null!;
    private MudTextField<string> newTaskInputRef;
    private MudTextField<string> searchInputRef;
    private Guid? moveTaskId;
    private Guid? moveTargetProjectId;
    private Guid? pendingSubTaskFocusParentId;

    private sealed record UndoAction(string Description, Func<Task> UndoAsync);

    private sealed record TaskSnapshot(
        string Title,
        string Note,
        TaskPriority Priority,
        DomainTaskStatus Status,
        bool IsFocused,
        bool IsMarkedForToday,
        Guid? ProjectId,
        List<TaskSnapshot> Children);

    private string ShellClass => this.isSidebarCollapsed ? "tf-shell tf-shell-collapsed" : "tf-shell";

    private string SidebarClass => this.isSidebarCollapsed ? "tf-sidebar tf-sidebar-collapsed" : "tf-sidebar";

    [CascadingParameter(Name = "ToggleTheme")]
    public Func<Task> ToggleTheme { get; set; }

    [CascadingParameter]
    public bool IsDarkMode { get; set; }

    private Project selectedProject => this.selectedProjectId.HasValue ? this.projects.FirstOrDefault(p => p.Id == this.selectedProjectId.Value) : null;

    private string CurrentTitle => this.selectedProject?.Name
        ?? this.myTaskFlowSections.FirstOrDefault(s => s.Id == this.selectedSectionId)?.Name
        ?? "TaskFlow";

    private string CurrentSubtitle => this.selectedProject is null
        ? "Cross-project execution view"
        : $"{FilteredTasks.Count} task(s)";

    private string ViewToggleLabel => this.selectedProject?.ViewType == ProjectViewType.Board ? "List View" : "Board View";

    private List<TaskFlow.Domain.Task> FilteredTasks
    {
        get
        {
            IEnumerable<TaskFlow.Domain.Task> query = this.activeTasks;

            if (!string.IsNullOrWhiteSpace(this.searchQuery))
            {
                var normalized = this.searchQuery.Trim();
                query = query.Where(task =>
                    task.Title.Contains(normalized, StringComparison.OrdinalIgnoreCase)
                    || (task.Note?.Contains(normalized, StringComparison.OrdinalIgnoreCase) ?? false));
            }

            if (this.priorityFilter.HasValue)
            {
                query = query.Where(task => task.Priority == this.priorityFilter.Value);
            }

            if (this.statusFilter.HasValue)
            {
                query = query.Where(task => task.Status == this.statusFilter.Value);
            }

            if (!this.showCompleted)
            {
                query = query.Where(task => !task.IsCompleted);
            }

            query = this.sortMode switch
            {
                SortMode.CreatedAsc => query.OrderBy(task => task.CreatedAt),
                SortMode.Priority => query.OrderByDescending(task => task.Priority).ThenByDescending(task => task.CreatedAt),
                SortMode.Focused => query.Where(task => task.IsFocused).OrderByDescending(task => task.CreatedAt),
                _ => query.OrderByDescending(task => task.CreatedAt),
            };

            return query.Where(task => !task.ParentTaskId.HasValue).ToList();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await ReloadAllAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!this.pendingSubTaskFocusParentId.HasValue)
        {
            return;
        }

        var parentTaskId = this.pendingSubTaskFocusParentId.Value;
        this.pendingSubTaskFocusParentId = null;
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusById", GetSubTaskInputId(parentTaskId));
    }

    private async Task ReloadAllAsync()
    {
        this.projects = (await this.ProjectOrchestrator.GetAllAsync()).OrderBy(project => project.CreatedAt).ToList();
        this.myTaskFlowSections = await this.MyTaskFlowSectionOrchestrator.GetAllAsync();
        await RecalculateProjectTaskCountsAsync();

        if (!this.selectedProjectId.HasValue && !this.selectedSectionId.HasValue)
        {
            this.selectedProjectId = this.projects.FirstOrDefault()?.Id;
        }

        if (this.selectedProjectId.HasValue)
        {
            await LoadProjectTasksAsync(this.selectedProjectId.Value);
            var currentProject = this.projects.FirstOrDefault(project => project.Id == this.selectedProjectId.Value);
            if (currentProject is not null)
            {
                SetProjectEditor(currentProject);
            }
        }
        else if (this.selectedSectionId.HasValue)
        {
            await LoadSectionTasksAsync(this.selectedSectionId.Value);
        }
    }

    private async Task SelectProjectAsync(Guid projectId)
    {
        this.selectedProjectId = projectId;
        this.selectedSectionId = null;
        var project = this.projects.FirstOrDefault(item => item.Id == projectId);
        if (project is not null)
        {
            SetProjectEditor(project);
        }

        await LoadProjectTasksAsync(projectId);
    }

    private async Task SelectSectionAsync(Guid sectionId)
    {
        this.selectedSectionId = sectionId;
        this.selectedProjectId = null;
        await LoadSectionTasksAsync(sectionId);
    }

    private async Task LoadProjectTasksAsync(Guid projectId)
    {
        this.activeTasks = await this.TaskOrchestrator.GetByProjectIdAsync(projectId);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks)
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task LoadSectionTasksAsync(Guid sectionId)
    {
        this.activeTasks = await this.MyTaskFlowSectionOrchestrator.GetSectionTasksAsync(sectionId);
        this.subTasksByParent.Clear();
        foreach (var task in this.activeTasks.Where(x => !x.ParentTaskId.HasValue))
        {
            this.subTasksByParent[task.Id] = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        }
    }

    private async Task CreateProjectAsync()
    {
        if (string.IsNullOrWhiteSpace(this.newProjectName))
        {
            return;
        }

        var created = await this.ProjectOrchestrator.CreateAsync(this.newProjectName, this.projectColorOptions[0].Hex, "folder");
        this.newProjectName = string.Empty;
        await ReloadAllAsync();
        await SelectProjectAsync(created.Id);
        this.Snackbar.Add("Project created.", Severity.Success);
    }

    private void OpenEditProjectDialog()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        SetProjectEditor(this.selectedProject);
        this.showEditProjectDialog = true;
    }

    private void CloseEditProjectDialog()
    {
        this.showEditProjectDialog = false;
    }

    private async Task OnProjectNameEditedAsync(string value)
    {
        if (this.selectedProject is null || string.Equals(this.selectedProject.Name, value, StringComparison.Ordinal))
        {
            return;
        }

        this.editProjectName = value;
        await this.ProjectOrchestrator.UpdateNameAsync(this.selectedProject.Id, value);
        await ReloadAllAsync();
    }

    private async Task OnProjectColorEditedAsync(string value)
    {
        if (this.selectedProject is null || string.Equals(this.selectedProject.Color, value, StringComparison.Ordinal))
        {
            return;
        }

        this.editProjectColor = value;
        await this.ProjectOrchestrator.UpdateVisualsAsync(this.selectedProject.Id, value, this.editProjectIcon);
        await ReloadAllAsync();
    }

    private async Task OnProjectIconEditedAsync(string value)
    {
        if (this.selectedProject is null || string.Equals(this.selectedProject.Icon, value, StringComparison.Ordinal))
        {
            return;
        }

        this.editProjectIcon = value;
        await this.ProjectOrchestrator.UpdateVisualsAsync(this.selectedProject.Id, this.editProjectColor, value);
        await ReloadAllAsync();
    }

    private void OpenDeleteProjectDialog()
    {
        this.showDeleteProjectDialog = true;
    }

    private void CloseDeleteProjectDialog()
    {
        this.showDeleteProjectDialog = false;
    }

    private void OpenMoveTaskDialog(Guid taskId)
    {
        this.moveTaskId = taskId;
        this.moveTargetProjectId = this.activeTasks.FirstOrDefault(task => task.Id == taskId)?.ProjectId;
        this.showMoveTaskDialog = true;
    }

    private void CloseMoveTaskDialog()
    {
        this.showMoveTaskDialog = false;
        this.moveTaskId = null;
        this.moveTargetProjectId = null;
    }

    private async Task ConfirmMoveTaskAsync()
    {
        if (!this.moveTaskId.HasValue)
        {
            return;
        }

        var task = this.activeTasks.FirstOrDefault(item => item.Id == this.moveTaskId.Value);
        if (task is null)
        {
            CloseMoveTaskDialog();
            return;
        }

        await MoveTaskAsync(task, this.moveTargetProjectId);
        CloseMoveTaskDialog();
    }

    private async Task DeleteProjectAsync()
    {
        if (this.selectedProject is null || this.selectedProject.IsDefault)
        {
            this.Snackbar.Add("Default project cannot be deleted.", Severity.Warning);
            return;
        }

        await this.ProjectOrchestrator.DeleteAsync(this.selectedProject.Id);
        this.selectedProjectId = null;
        this.showDeleteProjectDialog = false;
        await ReloadAllAsync();
        this.Snackbar.Add("Project deleted.", Severity.Info);
    }

    private async Task CreateTaskAsync()
    {
        if (string.IsNullOrWhiteSpace(this.newTaskTitle))
        {
            return;
        }

        if (this.selectedProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(this.selectedProjectId.Value, this.newTaskTitle, this.newTaskPriority, string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(this.newTaskTitle, this.newTaskPriority, string.Empty);
        }

        this.newTaskTitle = string.Empty;
        await InvokeAsync(StateHasChanged);
        if (this.newTaskInputRef is not null)
        {
            await this.newTaskInputRef.FocusAsync();
        }

        await ReloadCurrentTasksAsync();
        this.Snackbar.Add("Task created.", Severity.Success);
    }

    private async Task CreateSubTaskAsync(Guid parentTaskId)
    {
        if (!this.newSubTaskTitles.TryGetValue(parentTaskId, out var title) || string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId, title, TaskPriority.Medium, string.Empty);

        this.newSubTaskTitles[parentTaskId] = string.Empty;
        this.pendingSubTaskFocusParentId = parentTaskId;
        await ReloadCurrentTasksAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleCreateSubTaskKeyUp(Guid parentTaskId, KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateSubTaskAsync(parentTaskId);
        }
    }

    private async Task ToggleCompleteAsync(TaskFlow.Domain.Task task)
    {
        var target = task.IsCompleted ? DomainTaskStatus.New : DomainTaskStatus.Done;
        var previousStatus = task.Status;
        PushUndoAction("toggle completion", async () =>
        {
            await this.TaskOrchestrator.SetStatusAsync(task.Id, previousStatus);
        });

        await this.TaskOrchestrator.SetStatusAsync(task.Id, target);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        var statusMessage = target == DomainTaskStatus.Done ? "Task completed." : "Task restored.";
        this.Snackbar.Add($"{statusMessage} Press Ctrl/Cmd+Z to undo.", Severity.Success);
    }

    private async Task UpdateTitleAsync(TaskFlow.Domain.Task task, string value)
    {
        if (string.Equals(task.Title, value, StringComparison.Ordinal))
        {
            return;
        }

        await this.TaskOrchestrator.UpdateTitleAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateNoteAsync(TaskFlow.Domain.Task task, string value)
    {
        await this.TaskOrchestrator.UpdateNoteAsync(task.Id, value);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdatePriorityAsync(TaskFlow.Domain.Task task, TaskPriority priority)
    {
        await this.TaskOrchestrator.SetPriorityAsync(task.Id, priority);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task UpdateStatusAsync(TaskFlow.Domain.Task task, DomainTaskStatus status)
    {
        await this.TaskOrchestrator.SetStatusAsync(task.Id, status);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task ToggleFocusAsync(TaskFlow.Domain.Task task)
    {
        var wasFocused = task.IsFocused;
        PushUndoAction("toggle focus", async () =>
        {
            var current = this.activeTasks.FirstOrDefault(x => x.Id == task.Id);
            if (current is null || current.IsFocused != wasFocused)
            {
                await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
            }
        });

        await this.TaskOrchestrator.ToggleFocusAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task DeleteTaskAsync(TaskFlow.Domain.Task task)
    {
        var snapshot = await CaptureTaskSnapshotAsync(task);
        PushUndoAction("delete task", async () =>
        {
            await RestoreTaskSnapshotAsync(snapshot);
        });

        await this.TaskOrchestrator.DeleteAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task deleted. Press Ctrl/Cmd+Z to undo.", Severity.Info);
    }

    private async Task DuplicateTaskAsync(TaskFlow.Domain.Task task)
    {
        var title = $"{task.Title} (Copy)";
        if (task.ProjectId.HasValue)
        {
            await this.TaskOrchestrator.CreateAsync(task.ProjectId.Value, title, task.Priority, task.Note ?? string.Empty);
        }
        else
        {
            await this.TaskOrchestrator.CreateUnassignedAsync(title, task.Priority, task.Note ?? string.Empty);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add("Task duplicated.", Severity.Info);
    }

    private async Task ToggleTodayMarkAsync(TaskFlow.Domain.Task task)
    {
        await this.TaskOrchestrator.ToggleTodayMarkAsync(task.Id);
        await ReloadCurrentTasksAsync();
        StateHasChanged();
    }

    private async Task MoveTaskAsync(TaskFlow.Domain.Task task, Guid? projectId)
    {
        var previousProjectId = task.ProjectId;
        PushUndoAction("move task", async () =>
        {
            if (previousProjectId.HasValue)
            {
                await this.TaskOrchestrator.MoveToProjectAsync(task.Id, previousProjectId.Value);
            }
            else
            {
                await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
            }
        });

        if (projectId.HasValue)
        {
            await this.TaskOrchestrator.MoveToProjectAsync(task.Id, projectId.Value);
        }
        else
        {
            await this.TaskOrchestrator.UnassignFromProjectAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        await RecalculateProjectTaskCountsAsync();
        StateHasChanged();
        this.Snackbar.Add("Task moved.", Severity.Info);
    }

    private async Task ToggleProjectViewAsync()
    {
        if (this.selectedProject is null)
        {
            return;
        }

        var next = this.selectedProject.ViewType == ProjectViewType.Board
            ? ProjectViewType.List
            : ProjectViewType.Board;
        await this.ProjectOrchestrator.UpdateViewTypeAsync(this.selectedProject.Id, next);
        await ReloadAllAsync();
    }

    private async Task ClearCompletedAsync()
    {
        var completed = this.activeTasks.Where(task => task.IsCompleted).ToList();
        var completedIds = completed.Select(task => task.Id).ToHashSet();
        var rootCompleted = completed.Where(task => !task.ParentTaskId.HasValue || !completedIds.Contains(task.ParentTaskId.Value)).ToList();
        var snapshots = new List<TaskSnapshot>();
        foreach (var task in rootCompleted)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(task));
        }

        PushUndoAction("clear completed tasks", async () =>
        {
            foreach (var snapshot in snapshots)
            {
                await RestoreTaskSnapshotAsync(snapshot);
            }
        });

        foreach (var task in completed)
        {
            await this.TaskOrchestrator.DeleteAsync(task.Id);
        }

        await ReloadCurrentTasksAsync();
        StateHasChanged();
        this.Snackbar.Add($"Cleared {completed.Count} completed task(s). Press Ctrl/Cmd+Z to undo.", Severity.Warning);
    }

    private async Task ReloadCurrentTasksAsync()
    {
        if (this.selectedProjectId.HasValue)
        {
            await LoadProjectTasksAsync(this.selectedProjectId.Value);
            return;
        }

        if (this.selectedSectionId.HasValue)
        {
            await LoadSectionTasksAsync(this.selectedSectionId.Value);
        }
    }

    private List<TaskFlow.Domain.Task> GetBoardTasks(DomainTaskStatus status)
    {
        return this.FilteredTasks.Where(task => task.Status == status).ToList();
    }

    private async Task RecalculateProjectTaskCountsAsync()
    {
        this.projectTaskCounts.Clear();
        foreach (var project in this.projects)
        {
            var projectTasks = await this.TaskOrchestrator.GetByProjectIdAsync(project.Id);
            var count = projectTasks.Count(task => !task.IsCompleted);
            foreach (var task in projectTasks)
            {
                var subtasks = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
                count += subtasks.Count(subTask => !subTask.IsCompleted);
            }

            this.projectTaskCounts[project.Id] = count;
        }
    }

    private int GetProjectTaskCount(Guid projectId)
    {
        return this.projectTaskCounts.TryGetValue(projectId, out var count) ? count : 0;
    }

    private void SetProjectEditor(Project project)
    {
        this.editProjectName = project.Name;
        this.editProjectColor = project.Color;
        this.editProjectIcon = project.Icon;
    }

    private string ResolveProjectIcon(string icon)
    {
        return icon?.ToLowerInvariant() switch
        {
            "inbox" => Icons.Material.Filled.Inbox,
            "work" => Icons.Material.Filled.Work,
            "code" => Icons.Material.Filled.Code,
            "flag" => Icons.Material.Filled.Flag,
            _ => Icons.Material.Filled.Folder,
        };
    }

    private string GetTaskContainerClass(TaskFlow.Domain.Task task, bool isSubTask)
    {
        var baseClass = isSubTask ? "tf-subtask" : "tf-task";
        if (!task.CompletedAt.HasValue)
        {
            return baseClass;
        }

        return task.CompletedAt.Value >= DateTime.UtcNow.AddMinutes(-15)
            ? $"{baseClass} tf-task-recent"
            : baseClass;
    }

    private void PushUndoAction(string description, Func<Task> undoAsync)
    {
        if (this.isApplyingUndo)
        {
            return;
        }

        if (this.undoActions.Count >= MaxUndoActions)
        {
            this.undoActions.Clear();
        }

        this.undoActions.Push(new UndoAction(description, undoAsync));
    }

    private async Task UndoLastActionAsync()
    {
        if (!this.undoActions.TryPop(out var action))
        {
            this.Snackbar.Add("Nothing to undo.", Severity.Normal);
            return;
        }

        try
        {
            this.isApplyingUndo = true;
            await action.UndoAsync();
            await ReloadCurrentTasksAsync();
            await RecalculateProjectTaskCountsAsync();
            this.Snackbar.Add($"Undid: {action.Description}", Severity.Success);
        }
        finally
        {
            this.isApplyingUndo = false;
        }
    }

    private async Task<TaskSnapshot> CaptureTaskSnapshotAsync(TaskFlow.Domain.Task task)
    {
        var children = await this.TaskOrchestrator.GetSubTasksAsync(task.Id);
        var snapshots = new List<TaskSnapshot>();
        foreach (var child in children)
        {
            snapshots.Add(await CaptureTaskSnapshotAsync(child));
        }

        return new TaskSnapshot(
            task.Title,
            task.Note ?? string.Empty,
            task.Priority,
            task.Status,
            task.IsFocused,
            task.IsMarkedForToday,
            task.ProjectId,
            snapshots);
    }

    private async Task RestoreTaskSnapshotAsync(TaskSnapshot snapshot, Guid? parentTaskId = null)
    {
        TaskFlow.Domain.Task recreated;
        if (parentTaskId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateSubTaskAsync(parentTaskId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else if (snapshot.ProjectId.HasValue)
        {
            recreated = await this.TaskOrchestrator.CreateAsync(snapshot.ProjectId.Value, snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }
        else
        {
            recreated = await this.TaskOrchestrator.CreateUnassignedAsync(snapshot.Title, snapshot.Priority, snapshot.Note ?? string.Empty);
        }

        if (snapshot.Status != DomainTaskStatus.New)
        {
            await this.TaskOrchestrator.SetStatusAsync(recreated.Id, snapshot.Status);
        }

        if (snapshot.IsFocused)
        {
            await this.TaskOrchestrator.ToggleFocusAsync(recreated.Id);
        }

        if (snapshot.IsMarkedForToday)
        {
            await this.TaskOrchestrator.ToggleTodayMarkAsync(recreated.Id);
        }

        foreach (var child in snapshot.Children)
        {
            await RestoreTaskSnapshotAsync(child, recreated.Id);
        }
    }

    private string GetNewSubTaskTitle(Guid parentTaskId)
    {
        return this.newSubTaskTitles.TryGetValue(parentTaskId, out var value) ? value : string.Empty;
    }

    private static string GetSubTaskInputId(Guid parentTaskId)
    {
        return $"subtask-input-{parentTaskId:N}";
    }

    private void SetNewSubTaskTitle(Guid parentTaskId, string value)
    {
        this.newSubTaskTitles[parentTaskId] = value;
    }

    private async Task HandleCreateTaskKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateTaskAsync();
        }
    }

    private async Task HandleCreateProjectKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateProjectAsync();
        }
    }

    private Task HandleEditProjectDialogKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            CloseEditProjectDialog();
        }

        return Task.CompletedTask;
    }

    private Task ToggleThemeAsync()
    {
        return this.ToggleTheme?.Invoke() ?? Task.CompletedTask;
    }

    private Task OnTimerPresetChangedAsync(int minutes)
    {
        this.selectedTimerMinutes = minutes;
        if (!this.timerRunning)
        {
            this.timerRemaining = TimeSpan.FromMinutes(minutes);
        }

        return Task.CompletedTask;
    }

    private async Task HandleShellKeyDown(KeyboardEventArgs args)
    {
        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("Enter", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleCompleteAsync(task);
            }
        }

        if (args.Key == "Delete" && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await DeleteTaskAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("n", StringComparison.OrdinalIgnoreCase))
        {
            if (this.newTaskInputRef is not null)
            {
                await this.newTaskInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("f", StringComparison.OrdinalIgnoreCase))
        {
            if (this.searchInputRef is not null)
            {
                await this.searchInputRef.FocusAsync();
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("p", StringComparison.OrdinalIgnoreCase) && this.selectedTaskId.HasValue)
        {
            var task = this.activeTasks.FirstOrDefault(x => x.Id == this.selectedTaskId.Value);
            if (task is not null)
            {
                await ToggleFocusAsync(task);
            }
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key.Equals("z", StringComparison.OrdinalIgnoreCase))
        {
            await UndoLastActionAsync();
        }

        if ((args.CtrlKey || args.MetaKey) && args.Key == "/")
        {
            ToggleShortcutsHelp();
        }
    }

    private void ToggleShortcutsHelp()
    {
        this.showShortcuts = !this.showShortcuts;
    }

    private void ToggleSidebarCollapse()
    {
        this.isSidebarCollapsed = !this.isSidebarCollapsed;
    }

    private async Task StartTimer()
    {
        if (this.timerRunning)
        {
            return;
        }

        this.timerRunning = true;
        this.timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        this.timerCts = new CancellationTokenSource();
        await PlayTimerBeepAsync("start");
        _ = RunTimerAsync(this.timer, this.timerCts.Token);
    }

    private async Task RunTimerAsync(PeriodicTimer localTimer, CancellationToken cancellationToken)
    {
        while (await localTimer.WaitForNextTickAsync(cancellationToken))
        {
            if (this.timerRemaining <= TimeSpan.Zero)
            {
                this.timerRunning = false;
                this.Snackbar.Add("Focus session complete.", Severity.Success);
                await PlayTimerBeepAsync("finish");
                await InvokeAsync(StateHasChanged);
                return;
            }

            this.timerRemaining -= TimeSpan.FromSeconds(1);
            await InvokeAsync(StateHasChanged);
        }
    }

    private void PauseTimer()
    {
        this.timerRunning = false;
        this.timerCts?.Cancel();
        this.timer?.Dispose();
        this.timer = null;
    }

    private void ResetTimer()
    {
        PauseTimer();
        this.timerRemaining = TimeSpan.FromMinutes(this.selectedTimerMinutes);
    }

    private async Task PlayTimerBeepAsync(string eventType)
    {
        try
        {
            await this.JsRuntime.InvokeVoidAsync("taskflowAudio.beep", eventType);
        }
        catch
        {
            // Ignore audio errors to avoid breaking interaction flow.
        }
    }
}

@if (showEditProjectDialog)
{
    <div class="tf-shortcuts-backdrop" @onclick="CloseEditProjectDialog">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true" tabindex="0" @onkeydown="HandleEditProjectDialogKeyDown">
            <MudText Typo="Typo.h6">Edit Project</MudText>
            <MudTextField T="string" Value="editProjectName" ValueChanged="OnProjectNameEditedAsync" Label="Project name" Variant="Variant.Outlined" Margin="Margin.Dense" />
            <MudSelect T="string" Value="editProjectColor" ValueChanged="OnProjectColorEditedAsync" Label="Color" Variant="Variant.Outlined" Dense="true">
                @foreach (var option in projectColorOptions)
                {
                    <MudSelectItem Value="@option.Hex">
                        <span class="tf-color-option">
                            <span class="tf-color-swatch" style="@($"background:{option.Hex}")"></span>
                            <span>@option.Name</span>
                        </span>
                    </MudSelectItem>
                }
            </MudSelect>
            <MudSelect T="string" Value="editProjectIcon" ValueChanged="OnProjectIconEditedAsync" Label="Icon" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@("folder")">Folder</MudSelectItem>
                <MudSelectItem Value="@("inbox")">Inbox</MudSelectItem>
                <MudSelectItem Value="@("work")">Work</MudSelectItem>
                <MudSelectItem Value="@("code")">Code</MudSelectItem>
                <MudSelectItem Value="@("flag")">Flag</MudSelectItem>
            </MudSelect>
            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Outlined" OnClick="CloseEditProjectDialog">Done</MudButton>
            </MudStack>
        </MudPaper>
    </div>
}

@if (showMoveTaskDialog)
{
    <div class="tf-shortcuts-backdrop" @onclick="CloseMoveTaskDialog">
        <MudPaper Class="tf-shortcuts-dialog" @onclick:stopPropagation="true">
            <MudText Typo="Typo.h6">Move Task</MudText>
            <MudSelect T="Guid?" Value="moveTargetProjectId" ValueChanged="value => moveTargetProjectId = value" Label="Select project" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="@((Guid?)null)">Unassigned</MudSelectItem>
                @foreach (var project in projects)
                {
                    <MudSelectItem Value="@((Guid?)project.Id)">@project.Name</MudSelectItem>
                }
            </MudSelect>
            <MudStack Row="true" Spacing="1" Class="mt-3">
                <MudButton Variant="Variant.Outlined" OnClick="CloseMoveTaskDialog">Cancel</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ConfirmMoveTaskAsync">Move</MudButton>
            </MudStack>
        </MudPaper>
    </div>
}
