@using TaskFlow.Domain
@inject IJSRuntime JsRuntime

<MudStack Spacing="2">
    @if (Tasks.Count == 0)
    {
        <MudPaper Elevation="0" Class="pa-4 text-center">
            <MudText Typo="Typo.h6">No tasks yet</MudText>
            <MudText Typo="Typo.body2">Create your first task and keep momentum going.</MudText>
        </MudPaper>
    }
    else
    {
        @foreach (var task in Tasks)
        {
            <MudPaper id="@GetTaskContainerId(task.Id)" Elevation="1" Class="pa-2">
                <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="1">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="tf-task-title-group">
                        <MudCheckBox T="bool"
                                     Value="task.IsCompleted"
                                     ValueChanged="_ => OnToggleCompleteRequested.InvokeAsync(task.Id)"
                                     Size="Size.Small"
                                     Color="Color.Success"
                                     @onmousedown:stopPropagation="true"
                                     @onclick:stopPropagation="true" />
                        <MudTooltip Text="Toggle focus pin">
                            <span @onmousedown:stopPropagation="true" @onclick:stopPropagation="true">
                                <MudIconButton Icon="@(IsFocused(task) ? Icons.Material.Filled.PushPin : Icons.Material.Outlined.PushPin)"
                                               Color="@(IsFocused(task) ? Color.Success : Color.Default)"
                                               Class="@(IsFocused(task) ? "tf-toggle-active" : string.Empty)"
                                               Size="Size.Small"
                                               aria-label="Toggle focus pin"
                                               title="Toggle focus pin"
                                               Disabled="@task.IsCompleted"
                                               OnClick="() => ToggleFocusAsync(task)" />
                            </span>
                        </MudTooltip>
                        <MudTooltip Text="Toggle today">
                            <span @onmousedown:stopPropagation="true" @onclick:stopPropagation="true">
                                <MudIconButton Icon="@Icons.Material.Filled.Today"
                                               Color="@(IsMarkedForToday(task) ? Color.Primary : Color.Default)"
                                               Class="@(IsMarkedForToday(task) ? "tf-toggle-active" : string.Empty)"
                                               Size="Size.Small"
                                               aria-label="Toggle today"
                                               title="Toggle today"
                                               Disabled="@task.IsCompleted"
                                               OnClick="() => ToggleTodayAsync(task)" />
                            </span>
                        </MudTooltip>
                        @if (IsEditing(task.Id))
                        {
                            <MudTextField T="string"
                                          Value="editingTitle"
                                          ValueChanged="OnEditingTitleChanged"
                                          Variant="Variant.Text"
                                          Immediate="true"
                                          Margin="Margin.Dense"
                                          Class="@(task.IsCompleted ? "tf-task-title-done" : string.Empty)"
                                          @onmousedown:stopPropagation="true"
                                          OnKeyDown="args => HandleEditKeyDownAsync(task, args)"
                                          @onfocusout="() => CommitEditAsync(task)" />
                        }
                        else
                        {
                            <span @onmousedown:stopPropagation="true"
                                  @onmousedown="() => BeginEdit(task)">
                                <MudText Typo="Typo.body1"
                                         Class="@(task.IsCompleted ? "tf-task-title-done tf-task-title-truncate" : "tf-task-title-truncate")"
                                         title="@task.Title"
                                         Style="@GetTaskTitleStyle(task)">
                                    @task.Title
                                </MudText>
                            </span>
                        }
                    </MudStack>
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudTooltip Text="Toggle important">
                            <span @onmousedown:stopPropagation="true" @onclick:stopPropagation="true">
                                <MudIconButton Icon="@(IsImportant(task) ? Icons.Material.Filled.Star : Icons.Material.Outlined.StarBorder)"
                                               Color="@(IsImportant(task) ? Color.Warning : Color.Default)"
                                               Class="@(IsImportant(task) ? "tf-toggle-active" : string.Empty)"
                                               Size="Size.Small"
                                               aria-label="Toggle important"
                                               title="Toggle important"
                                               Disabled="@task.IsCompleted"
                                               OnClick="() => ToggleImportantAsync(task)" />
                            </span>
                        </MudTooltip>
                        <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                       Color="Color.Primary"
                                       Size="Size.Small"
                                       aria-label="Edit task"
                                       title="Edit task"
                                       Disabled="@task.IsCompleted"
                                       OnClick="() => OnEditTaskRequested.InvokeAsync(task.Id)" />
                    </MudStack>
                </MudStack>
            </MudPaper>
        }
    }
</MudStack>

@code {
    [Parameter, EditorRequired]
    public IReadOnlyList<TaskFlow.Domain.Task> Tasks { get; set; } = [];

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnEditTaskRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleCompleteRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleFocusRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleImportantRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleTodayRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<TitleUpdateRequest> OnUpdateTaskTitleRequested { get; set; }

    public sealed record TitleUpdateRequest(Guid TaskId, string Title);

    private Guid? editingTaskId;
    private Guid? pendingFocusTaskId;
    private string editingTitle = string.Empty;
    private readonly Dictionary<Guid, bool> focusedStates = [];
    private readonly Dictionary<Guid, bool> importantStates = [];
    private readonly Dictionary<Guid, bool> todayStates = [];

    private bool IsEditing(Guid taskId)
    {
        return this.editingTaskId == taskId;
    }

    protected override void OnParametersSet()
    {
        var taskLookup = this.Tasks.ToDictionary(task => task.Id);
        SyncLocalStates(this.focusedStates, taskLookup, task => task.IsFocused);
        SyncLocalStates(this.importantStates, taskLookup, task => task.IsImportant);
        SyncLocalStates(this.todayStates, taskLookup, task => task.IsMarkedForToday);
    }

    private void BeginEdit(TaskFlow.Domain.Task task)
    {
        if (task.IsCompleted)
        {
            return;
        }

        this.editingTaskId = task.Id;
        this.pendingFocusTaskId = task.Id;
        this.editingTitle = task.Title;
    }

    private void OnEditingTitleChanged(string value)
    {
        this.editingTitle = value;
    }

    private async System.Threading.Tasks.Task HandleEditKeyDownAsync(TaskFlow.Domain.Task task, KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            CancelEdit();
            return;
        }

        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CommitEditAsync(task);
        }
    }

    private async System.Threading.Tasks.Task CommitEditAsync(TaskFlow.Domain.Task task)
    {
        if (this.editingTaskId != task.Id)
        {
            return;
        }

        var updatedTitle = this.editingTitle?.Trim() ?? string.Empty;
        CancelEdit();

        if (string.IsNullOrWhiteSpace(updatedTitle) || string.Equals(updatedTitle, task.Title, StringComparison.Ordinal))
        {
            return;
        }

        await this.OnUpdateTaskTitleRequested.InvokeAsync(new TitleUpdateRequest(task.Id, updatedTitle));
    }

    private void CancelEdit()
    {
        this.editingTaskId = null;
        this.pendingFocusTaskId = null;
        this.editingTitle = string.Empty;
    }

    protected override async System.Threading.Tasks.Task OnAfterRenderAsync(bool firstRender)
    {
        if (!this.pendingFocusTaskId.HasValue || !this.editingTaskId.HasValue)
        {
            return;
        }

        if (this.pendingFocusTaskId.Value != this.editingTaskId.Value)
        {
            return;
        }

        var taskId = this.pendingFocusTaskId.Value;
        this.pendingFocusTaskId = null;
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusInputInContainerById", GetTaskContainerId(taskId));
    }

    private static string GetTaskContainerId(Guid taskId)
    {
        return $"list-task-{taskId:N}";
    }

    private static string GetTaskTitleStyle(TaskFlow.Domain.Task task)
    {
        return task.IsCompleted ? "cursor:default" : "cursor:text";
    }

    private bool IsImportant(TaskFlow.Domain.Task task)
    {
        return this.importantStates.TryGetValue(task.Id, out var state) ? state : task.IsImportant;
    }

    private bool IsFocused(TaskFlow.Domain.Task task)
    {
        return this.focusedStates.TryGetValue(task.Id, out var state) ? state : task.IsFocused;
    }

    private bool IsMarkedForToday(TaskFlow.Domain.Task task)
    {
        return this.todayStates.TryGetValue(task.Id, out var state) ? state : task.IsMarkedForToday;
    }

    private async System.Threading.Tasks.Task ToggleFocusAsync(TaskFlow.Domain.Task task)
    {
        var previous = IsFocused(task);
        this.focusedStates[task.Id] = !previous;
        await InvokeAsync(StateHasChanged);

        try
        {
            await this.OnToggleFocusRequested.InvokeAsync(task.Id);
        }
        catch
        {
            this.focusedStates[task.Id] = previous;
            await InvokeAsync(StateHasChanged);
            throw;
        }
    }

    private async System.Threading.Tasks.Task ToggleImportantAsync(TaskFlow.Domain.Task task)
    {
        var previous = IsImportant(task);
        this.importantStates[task.Id] = !previous;
        await InvokeAsync(StateHasChanged);

        try
        {
            await this.OnToggleImportantRequested.InvokeAsync(task.Id);
        }
        catch
        {
            this.importantStates[task.Id] = previous;
            await InvokeAsync(StateHasChanged);
            throw;
        }
    }

    private async System.Threading.Tasks.Task ToggleTodayAsync(TaskFlow.Domain.Task task)
    {
        var previous = IsMarkedForToday(task);
        this.todayStates[task.Id] = !previous;
        await InvokeAsync(StateHasChanged);

        try
        {
            await this.OnToggleTodayRequested.InvokeAsync(task.Id);
        }
        catch
        {
            this.todayStates[task.Id] = previous;
            await InvokeAsync(StateHasChanged);
            throw;
        }
    }

    private static void SyncLocalStates(
        Dictionary<Guid, bool> localStates,
        IReadOnlyDictionary<Guid, TaskFlow.Domain.Task> tasks,
        Func<TaskFlow.Domain.Task, bool> selector)
    {
        foreach (var key in localStates.Keys.Where(key => !tasks.ContainsKey(key)).ToList())
        {
            localStates.Remove(key);
        }

        foreach (var (taskId, task) in tasks)
        {
            if (!localStates.TryGetValue(taskId, out var local))
            {
                continue;
            }

            if (local == selector(task))
            {
                localStates.Remove(taskId);
            }
        }
    }
}
