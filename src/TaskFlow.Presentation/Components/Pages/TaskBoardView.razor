@using TaskFlow.Domain
@using DomainTaskStatus = TaskFlow.Domain.TaskStatus
@inject IJSRuntime JsRuntime

<MudDropContainer T="TaskFlow.Domain.Task"
                  @key="BoardRenderKey"
                  Items="BoardItems"
                  ItemsSelector="ItemInDropZone"
                  ItemDropped="HandleItemDropped"
                  Class="d-flex flex-wrap flex-grow-1">
    <ChildContent>
        @foreach (var status in BoardStatuses)
        {
            var boardTasks = GetBoardTasks.Invoke(status);
            <MudPaper Elevation="0" Class="pa-4 ma-2 d-flex flex-column flex-grow-1" MinHeight="340px" Style="min-width:260px;">
                <MudText Typo="Typo.subtitle1" Class="mb-2"><b>@status</b> (@boardTasks.Count)</MudText>
                <MudDropZone T="TaskFlow.Domain.Task" Identifier="@status.ToString()" Class="flex-grow-1" />
                @if (boardTasks.Count == 0)
                {
                    <MudText Typo="Typo.caption" Class="mt-2">Drop tasks here</MudText>
                }

                <MudStack Row="true" Spacing="1" Class="mt-2">
                    <MudTextField T="string"
                                  Value="@GetNewTaskTitle(status)"
                                  ValueChanged="value => SetNewTaskTitle(status, value)"
                                  Placeholder="Add task"
                                  Variant="Variant.Outlined"
                                  Margin="Margin.Dense"
                                  TextUpdateSuppression="false"
                                  OnKeyUp="args => HandleCreateTaskKeyUp(status, args)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Add" Color="Color.Primary" aria-label="Add task" title="Add task" OnClick="() => CreateTaskInStatusAsync(status)" />
                </MudStack>
            </MudPaper>
        }
    </ChildContent>
    <ItemRenderer>
        <MudPaper id="@GetTaskContainerId(context.Id)" Elevation="2" Class="pa-3 ma-2">
            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="1">
                @if (IsEditing(context.Id))
                {
                    <MudTextField T="string"
                                  Value="editingTitle"
                                  ValueChanged="OnEditingTitleChanged"
                                  Variant="Variant.Text"
                                  Immediate="true"
                                  Margin="Margin.Dense"
                                  @onmousedown:stopPropagation="true"
                                  OnKeyDown="args => HandleEditKeyDownAsync(context, args)"
                                  @onfocusout="() => CommitEditAsync(context)" />
                }
                else
                {
                    <MudButton Variant="Variant.Text"
                               Color="Color.Default"
                               Class="pa-0 ma-0"
                               Style="min-width: 0; text-transform: none; justify-content: flex-start;"
                               OnClick="() => BeginEdit(context)">
                        @context.Title
                    </MudButton>
                }
                <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Primary" Size="Size.Small" aria-label="Edit task" title="Edit task" OnClick="() => OnEditTaskRequested.InvokeAsync(context.Id)" />
            </MudStack>
        </MudPaper>
    </ItemRenderer>
</MudDropContainer>

@code {
    [Parameter, EditorRequired]
    public IReadOnlyList<DomainTaskStatus> BoardStatuses { get; set; } = [];

    [Parameter, EditorRequired]
    public Func<DomainTaskStatus, List<TaskFlow.Domain.Task>> GetBoardTasks { get; set; } = null!;

    [Parameter, EditorRequired]
    public EventCallback<BoardDropRequest> OnDropTaskToStatus { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<BoardCreateRequest> OnCreateTaskInStatus { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnEditTaskRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<TitleUpdateRequest> OnUpdateTaskTitleRequested { get; set; }

    private readonly Dictionary<DomainTaskStatus, string> newTaskTitles = [];

    public sealed record BoardDropRequest(TaskFlow.Domain.Task Task, DomainTaskStatus Status);
    public sealed record BoardCreateRequest(DomainTaskStatus Status, string Title);
    public sealed record TitleUpdateRequest(Guid TaskId, string Title);

    private List<TaskFlow.Domain.Task> BoardItems => this.BoardStatuses
        .SelectMany(status => this.GetBoardTasks.Invoke(status))
        .Where(task => !task.ParentTaskId.HasValue)
        .GroupBy(task => task.Id)
        .Select(group => group.First())
        .ToList();

    private string BoardRenderKey => $"{string.Join('|', this.BoardItems.Select(item => $"{item.Id:N}:{item.Status}"))}|edit:{this.editingTaskId?.ToString("N")}";
    private Guid? editingTaskId;
    private Guid? pendingFocusTaskId;
    private string editingTitle = string.Empty;

    private bool IsEditing(Guid taskId)
    {
        return this.editingTaskId == taskId;
    }

    private void BeginEdit(TaskFlow.Domain.Task task)
    {
        this.editingTaskId = task.Id;
        this.pendingFocusTaskId = task.Id;
        this.editingTitle = task.Title;
    }

    private void OnEditingTitleChanged(string value)
    {
        this.editingTitle = value;
    }

    private bool ItemInDropZone(TaskFlow.Domain.Task item, string dropZoneIdentifier)
    {
        return Enum.TryParse<DomainTaskStatus>(dropZoneIdentifier, out var status)
            && item.Status == status;
    }

    private async System.Threading.Tasks.Task HandleItemDropped(MudItemDropInfo<TaskFlow.Domain.Task> drop)
    {
        if (!Enum.TryParse<DomainTaskStatus>(drop.DropzoneIdentifier, out var status))
        {
            return;
        }

        if (drop.Item.Status == status)
        {
            return;
        }

        await this.OnDropTaskToStatus.InvokeAsync(new BoardDropRequest(drop.Item, status));
    }

    private string GetNewTaskTitle(DomainTaskStatus status)
    {
        return this.newTaskTitles.TryGetValue(status, out var value) ? value : string.Empty;
    }

    private void SetNewTaskTitle(DomainTaskStatus status, string value)
    {
        this.newTaskTitles[status] = value;
    }

    private async System.Threading.Tasks.Task HandleCreateTaskKeyUp(DomainTaskStatus status, KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateTaskInStatusAsync(status);
        }
    }

    private async System.Threading.Tasks.Task CreateTaskInStatusAsync(DomainTaskStatus status)
    {
        var title = GetNewTaskTitle(status);
        if (string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        this.newTaskTitles[status] = string.Empty;
        await this.OnCreateTaskInStatus.InvokeAsync(new BoardCreateRequest(status, title));
    }

    private async System.Threading.Tasks.Task HandleEditKeyDownAsync(TaskFlow.Domain.Task task, KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            CancelEdit();
            return;
        }

        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CommitEditAsync(task);
        }
    }

    private async System.Threading.Tasks.Task CommitEditAsync(TaskFlow.Domain.Task task)
    {
        if (this.editingTaskId != task.Id)
        {
            return;
        }

        var updatedTitle = this.editingTitle?.Trim() ?? string.Empty;
        CancelEdit();

        if (string.IsNullOrWhiteSpace(updatedTitle) || string.Equals(updatedTitle, task.Title, StringComparison.Ordinal))
        {
            return;
        }

        await this.OnUpdateTaskTitleRequested.InvokeAsync(new TitleUpdateRequest(task.Id, updatedTitle));
    }

    private void CancelEdit()
    {
        this.editingTaskId = null;
        this.pendingFocusTaskId = null;
        this.editingTitle = string.Empty;
    }

    protected override async System.Threading.Tasks.Task OnAfterRenderAsync(bool firstRender)
    {
        if (!this.pendingFocusTaskId.HasValue || !this.editingTaskId.HasValue)
        {
            return;
        }

        if (this.pendingFocusTaskId.Value != this.editingTaskId.Value)
        {
            return;
        }

        var taskId = this.pendingFocusTaskId.Value;
        this.pendingFocusTaskId = null;
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusInputInContainerById", GetTaskContainerId(taskId));
    }

    private static string GetTaskContainerId(Guid taskId)
    {
        return $"board-task-{taskId:N}";
    }
}
