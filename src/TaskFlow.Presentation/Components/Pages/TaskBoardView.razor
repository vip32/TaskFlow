@using TaskFlow.Domain
@using DomainTaskStatus = TaskFlow.Domain.TaskStatus
@inject IJSRuntime JsRuntime

<MudDropContainer T="TaskFlow.Domain.Task"
                  @key="BoardRenderKey"
                  Items="BoardItems"
                  ItemsSelector="ItemInDropZone"
                  ItemDropped="HandleItemDropped"
                  Class="tf-board-container">
    <ChildContent>
        @foreach (var status in BoardStatuses)
        {
            var boardTasks = GetBoardTasks.Invoke(status);
            <MudPaper Elevation="0" Class="pa-4 d-flex flex-column tf-board-lane" MinHeight="340px">
                <MudText Typo="Typo.subtitle1" Class="mb-2"><b>@status</b> (@boardTasks.Count)</MudText>
                <MudDropZone T="TaskFlow.Domain.Task" Identifier="@status.ToString()" Class="flex-grow-1" />
                @if (boardTasks.Count == 0)
                {
                    <MudText Typo="Typo.caption" Class="mt-2">Drop tasks here</MudText>
                }

                <MudStack Row="true" Spacing="1" Class="mt-2">
                    <MudTextField T="string"
                                  Value="@GetNewTaskTitle(status)"
                                  ValueChanged="value => SetNewTaskTitle(status, value)"
                                  Placeholder="Add task"
                                  Variant="Variant.Outlined"
                                  Margin="Margin.Dense"
                                  TextUpdateSuppression="false"
                                  OnKeyUp="args => HandleCreateTaskKeyUp(status, args)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Add" Color="Color.Primary" aria-label="Add task" title="Add task" OnClick="() => CreateTaskInStatusAsync(status)" />
                </MudStack>
            </MudPaper>
        }
    </ChildContent>
    <ItemRenderer>
        <MudPaper id="@GetTaskContainerId(context.Id)" Elevation="2" Class="pa-3 ma-2">
            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="1">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="tf-task-title-group">
                    <MudCheckBox T="bool"
                                 Value="context.IsCompleted"
                                 ValueChanged="_ => OnToggleCompleteRequested.InvokeAsync(context.Id)"
                                 Size="Size.Small"
                                 Color="Color.Success"
                                 @onmousedown:stopPropagation="true"
                                 @onclick:stopPropagation="true" />
                    <MudTooltip Text="Toggle focus pin">
                        <span @onmousedown:stopPropagation="true" @onclick:stopPropagation="true">
                            <MudIconButton Icon="@(IsFocused(context) ? Icons.Material.Filled.PushPin : Icons.Material.Outlined.PushPin)"
                                           Color="@(IsFocused(context) ? Color.Success : Color.Default)"
                                           Class="@(IsFocused(context) ? "tf-toggle-active" : string.Empty)"
                                           Size="Size.Small"
                                           aria-label="Toggle focus pin"
                                           title="Toggle focus pin"
                                           Disabled="@context.IsCompleted"
                                           OnClick="() => ToggleFocusAsync(context)" />
                        </span>
                    </MudTooltip>
                    <MudTooltip Text="Toggle today">
                        <span @onmousedown:stopPropagation="true" @onclick:stopPropagation="true">
                            <MudIconButton Icon="@Icons.Material.Filled.Today"
                                           Color="@(IsMarkedForToday(context) ? Color.Primary : Color.Default)"
                                           Class="@(IsMarkedForToday(context) ? "tf-toggle-active" : string.Empty)"
                                           Size="Size.Small"
                                           aria-label="Toggle today"
                                           title="Toggle today"
                                           Disabled="@context.IsCompleted"
                                           OnClick="() => ToggleTodayAsync(context)" />
                        </span>
                    </MudTooltip>
                    @if (IsEditing(context.Id))
                    {
                        <MudTextField T="string"
                                      Value="editingTitle"
                                      ValueChanged="OnEditingTitleChanged"
                                      Variant="Variant.Text"
                                      Immediate="true"
                                      Margin="Margin.Dense"
                                      Class="@(context.IsCompleted ? "tf-task-title-done" : string.Empty)"
                                      @onmousedown:stopPropagation="true"
                                      OnKeyDown="args => HandleEditKeyDownAsync(context, args)"
                                      @onfocusout="() => CommitEditAsync(context)" />
                    }
                    else
                    {
                        <MudButton Variant="Variant.Text"
                                   Color="Color.Default"
                                   Class="@GetTaskTitleButtonClass(context)"
                                   Style="text-transform: none; justify-content: flex-start;"
                                   title="@context.Title"
                                   Disabled="@context.IsCompleted"
                                   OnClick="() => BeginEdit(context)">
                            @context.Title
                        </MudButton>
                    }
                </MudStack>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudTooltip Text="Toggle important">
                        <span @onmousedown:stopPropagation="true" @onclick:stopPropagation="true">
                            <MudIconButton Icon="@(IsImportant(context) ? Icons.Material.Filled.Star : Icons.Material.Outlined.StarBorder)"
                                           Color="@(IsImportant(context) ? Color.Warning : Color.Default)"
                                           Class="@(IsImportant(context) ? "tf-toggle-active" : string.Empty)"
                                           Size="Size.Small"
                                           aria-label="Toggle important"
                                           title="Toggle important"
                                           Disabled="@context.IsCompleted"
                                           OnClick="() => ToggleImportantAsync(context)" />
                        </span>
                    </MudTooltip>
                    <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                   Color="Color.Primary"
                                   Size="Size.Small"
                                   aria-label="Edit task"
                                   title="Edit task"
                                   Disabled="@context.IsCompleted"
                                   OnClick="() => OnEditTaskRequested.InvokeAsync(context.Id)" />
                </MudStack>
            </MudStack>
        </MudPaper>
    </ItemRenderer>
</MudDropContainer>

@code {
    [Parameter, EditorRequired]
    public IReadOnlyList<DomainTaskStatus> BoardStatuses { get; set; } = [];

    [Parameter, EditorRequired]
    public Func<DomainTaskStatus, List<TaskFlow.Domain.Task>> GetBoardTasks { get; set; } = null!;

    [Parameter, EditorRequired]
    public EventCallback<BoardDropRequest> OnDropTaskToStatus { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<BoardCreateRequest> OnCreateTaskInStatus { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnEditTaskRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleCompleteRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleFocusRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleImportantRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<Guid> OnToggleTodayRequested { get; set; }

    [Parameter, EditorRequired]
    public EventCallback<TitleUpdateRequest> OnUpdateTaskTitleRequested { get; set; }

    private readonly Dictionary<DomainTaskStatus, string> newTaskTitles = [];

    public sealed record BoardDropRequest(TaskFlow.Domain.Task Task, DomainTaskStatus Status);
    public sealed record BoardCreateRequest(DomainTaskStatus Status, string Title);
    public sealed record TitleUpdateRequest(Guid TaskId, string Title);

    private List<TaskFlow.Domain.Task> BoardItems => this.BoardStatuses
        .SelectMany(status => this.GetBoardTasks.Invoke(status))
        .Where(task => !task.ParentTaskId.HasValue)
        .GroupBy(task => task.Id)
        .Select(group => group.First())
        .ToList();

    private string BoardRenderKey => $"{string.Join('|', this.BoardItems.Select(item => $"{item.Id:N}:{item.Status}:{item.IsCompleted}:{IsFocused(item)}:{IsImportant(item)}:{IsMarkedForToday(item)}:{item.Title}"))}|edit:{this.editingTaskId?.ToString("N")}";
    private Guid? editingTaskId;
    private Guid? pendingFocusTaskId;
    private string editingTitle = string.Empty;
    private readonly Dictionary<Guid, bool> focusedStates = [];
    private readonly Dictionary<Guid, bool> importantStates = [];
    private readonly Dictionary<Guid, bool> todayStates = [];

    private bool IsEditing(Guid taskId)
    {
        return this.editingTaskId == taskId;
    }

    protected override void OnParametersSet()
    {
        var taskLookup = this.BoardItems.ToDictionary(task => task.Id);
        SyncLocalStates(this.focusedStates, taskLookup, task => task.IsFocused);
        SyncLocalStates(this.importantStates, taskLookup, task => task.IsImportant);
        SyncLocalStates(this.todayStates, taskLookup, task => task.IsMarkedForToday);
    }

    private void BeginEdit(TaskFlow.Domain.Task task)
    {
        if (task.IsCompleted)
        {
            return;
        }

        this.editingTaskId = task.Id;
        this.pendingFocusTaskId = task.Id;
        this.editingTitle = task.Title;
    }

    private void OnEditingTitleChanged(string value)
    {
        this.editingTitle = value;
    }

    private bool ItemInDropZone(TaskFlow.Domain.Task item, string dropZoneIdentifier)
    {
        return Enum.TryParse<DomainTaskStatus>(dropZoneIdentifier, out var status)
            && item.Status == status;
    }

    private async System.Threading.Tasks.Task HandleItemDropped(MudItemDropInfo<TaskFlow.Domain.Task> drop)
    {
        if (!Enum.TryParse<DomainTaskStatus>(drop.DropzoneIdentifier, out var status))
        {
            return;
        }

        if (drop.Item.Status == status)
        {
            return;
        }

        if (drop.Item.IsCompleted)
        {
            return;
        }

        await this.OnDropTaskToStatus.InvokeAsync(new BoardDropRequest(drop.Item, status));
    }

    private string GetNewTaskTitle(DomainTaskStatus status)
    {
        return this.newTaskTitles.TryGetValue(status, out var value) ? value : string.Empty;
    }

    private void SetNewTaskTitle(DomainTaskStatus status, string value)
    {
        this.newTaskTitles[status] = value;
    }

    private async System.Threading.Tasks.Task HandleCreateTaskKeyUp(DomainTaskStatus status, KeyboardEventArgs args)
    {
        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CreateTaskInStatusAsync(status);
        }
    }

    private async System.Threading.Tasks.Task CreateTaskInStatusAsync(DomainTaskStatus status)
    {
        var title = GetNewTaskTitle(status);
        if (string.IsNullOrWhiteSpace(title))
        {
            return;
        }

        this.newTaskTitles[status] = string.Empty;
        await this.OnCreateTaskInStatus.InvokeAsync(new BoardCreateRequest(status, title));
    }

    private async System.Threading.Tasks.Task HandleEditKeyDownAsync(TaskFlow.Domain.Task task, KeyboardEventArgs args)
    {
        if (args.Key == "Escape")
        {
            CancelEdit();
            return;
        }

        if (args.Key == "Enter" || args.Key == "NumpadEnter")
        {
            await CommitEditAsync(task);
        }
    }

    private async System.Threading.Tasks.Task CommitEditAsync(TaskFlow.Domain.Task task)
    {
        if (this.editingTaskId != task.Id)
        {
            return;
        }

        var updatedTitle = this.editingTitle?.Trim() ?? string.Empty;
        CancelEdit();

        if (string.IsNullOrWhiteSpace(updatedTitle) || string.Equals(updatedTitle, task.Title, StringComparison.Ordinal))
        {
            return;
        }

        await this.OnUpdateTaskTitleRequested.InvokeAsync(new TitleUpdateRequest(task.Id, updatedTitle));
    }

    private void CancelEdit()
    {
        this.editingTaskId = null;
        this.pendingFocusTaskId = null;
        this.editingTitle = string.Empty;
    }

    protected override async System.Threading.Tasks.Task OnAfterRenderAsync(bool firstRender)
    {
        if (!this.pendingFocusTaskId.HasValue || !this.editingTaskId.HasValue)
        {
            return;
        }

        if (this.pendingFocusTaskId.Value != this.editingTaskId.Value)
        {
            return;
        }

        var taskId = this.pendingFocusTaskId.Value;
        this.pendingFocusTaskId = null;
        await this.JsRuntime.InvokeVoidAsync("taskflowUi.focusInputInContainerById", GetTaskContainerId(taskId));
    }

    private static string GetTaskContainerId(Guid taskId)
    {
        return $"board-task-{taskId:N}";
    }

    private static string GetTaskTitleButtonClass(TaskFlow.Domain.Task task)
    {
        return task.IsCompleted
            ? "pa-0 ma-0 tf-task-title-done tf-task-title-truncate"
            : "pa-0 ma-0 tf-task-title-truncate";
    }

    private bool IsImportant(TaskFlow.Domain.Task task)
    {
        return this.importantStates.TryGetValue(task.Id, out var state) ? state : task.IsImportant;
    }

    private bool IsFocused(TaskFlow.Domain.Task task)
    {
        return this.focusedStates.TryGetValue(task.Id, out var state) ? state : task.IsFocused;
    }

    private bool IsMarkedForToday(TaskFlow.Domain.Task task)
    {
        return this.todayStates.TryGetValue(task.Id, out var state) ? state : task.IsMarkedForToday;
    }

    private async System.Threading.Tasks.Task ToggleFocusAsync(TaskFlow.Domain.Task task)
    {
        var previous = IsFocused(task);
        this.focusedStates[task.Id] = !previous;
        await InvokeAsync(StateHasChanged);

        try
        {
            await this.OnToggleFocusRequested.InvokeAsync(task.Id);
        }
        catch
        {
            this.focusedStates[task.Id] = previous;
            await InvokeAsync(StateHasChanged);
            throw;
        }
    }

    private async System.Threading.Tasks.Task ToggleImportantAsync(TaskFlow.Domain.Task task)
    {
        var previous = IsImportant(task);
        this.importantStates[task.Id] = !previous;
        await InvokeAsync(StateHasChanged);

        try
        {
            await this.OnToggleImportantRequested.InvokeAsync(task.Id);
        }
        catch
        {
            this.importantStates[task.Id] = previous;
            await InvokeAsync(StateHasChanged);
            throw;
        }
    }

    private async System.Threading.Tasks.Task ToggleTodayAsync(TaskFlow.Domain.Task task)
    {
        var previous = IsMarkedForToday(task);
        this.todayStates[task.Id] = !previous;
        await InvokeAsync(StateHasChanged);

        try
        {
            await this.OnToggleTodayRequested.InvokeAsync(task.Id);
        }
        catch
        {
            this.todayStates[task.Id] = previous;
            await InvokeAsync(StateHasChanged);
            throw;
        }
    }

    private static void SyncLocalStates(
        Dictionary<Guid, bool> localStates,
        IReadOnlyDictionary<Guid, TaskFlow.Domain.Task> tasks,
        Func<TaskFlow.Domain.Task, bool> selector)
    {
        foreach (var key in localStates.Keys.Where(key => !tasks.ContainsKey(key)).ToList())
        {
            localStates.Remove(key);
        }

        foreach (var (taskId, task) in tasks)
        {
            if (!localStates.TryGetValue(taskId, out var local))
            {
                continue;
            }

            if (local == selector(task))
            {
                localStates.Remove(taskId);
            }
        }
    }
}
